\documentclass[11pt]{report}

\usepackage[a4paper,margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{adjustbox}
\usepackage[acronym,toc,nonumberlist,nogroupskip]{glossaries}
\usepackage{enumitem}
\usepackage{xltabular}
\usepackage{dirtree}
\usepackage{minted}
\usepackage{standalone}

\usepackage{tikz}
\usepackage{packages/tikz-uml}


% setup bibliography
\usepackage[style=ieee]{biblatex}
\addbibresource{references.bib}

% setup hyperlinks
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=black,
    linkcolor=blue,
    urlcolor=blue,
}

% setup debug box command for places things are missing
\newcommand{\todo}[1]{\fbox{\parbox{\textwidth}{\textbf{TO-DO:} #1}}}

% add footnotes without the \footnote{\url{...}} command
\newcommand{\ftnt}[1]{\footnote{\url{#1}}}

% Glossary entry
\makenoidxglossaries

\newglossaryentry{ppu_g}{
    name={Picture Processing Unit},
    description={The part of the Gameboy that is responsible for rendering the game}
}
\newglossaryentry{ppu}{
    type=\acronymtype,
    name={PPU},
    description={Picture Processing Unit},
    first={Picture Processing Unit (PPU)\glsadd{ppu_g}},
}

\newglossaryentry{gb}{
    type=\acronymtype,
    name=GB,
    description={Gameboy},
    first={Gameboy (GB)}
}

\newglossaryentry{gbc}{
    type=\acronymtype,
    name=GBC,
    description={Gameboy Color},
    first={Gameboy Color (GBC)}
}

\newglossaryentry{os}{
	type=\acronymtype,
	name=OS,
	description={Operating System},
	first={Operating System (OS)}
}

\newglossaryentry{cpu}{
    type=\acronymtype,
    name=CPU,
    description={Central Processing Unit},
    first={Central Processing Unit (CPU)}
}

\newglossaryentry{apu_g}{
    name={Audio Processing Unit},
    description={The part of the Gameboy that is responsible with processing the game's audio}
}

\newglossaryentry{apu}{
    type=\acronymtype,
    name=APU,
    description={Audio Processing Unit},
    first={Audio Processing Unit (APU)}
}

\newglossaryentry{rom}{
    type=\acronymtype,
    name={ROM},
    plural={ROMs},
    description={Read-Only Memory},
    first={Read-Only Memory (ROM)},
    firstplural={Read-Only Memory (ROM)}
}

\newglossaryentry{mbc}{
    type=\acronymtype,
    name={MBC},
    plural={MBCs},
    description={Memory Bank Controller},
    first={Memory Bank Controller (MBC)},
    firstplural={Memory Bank Controllers (MBCs)}
}

\newglossaryentry{oam}{
    type=\acronymtype,
    name={OAM},
    description={Object Attribute Memory},
    first={Object Attribute Memory (OAM)},
}

\newglossaryentry{vram}{
	type=\acronymtype,
	name={VRAM},
	description={Video RAM},
	first={Video RAM (VRAM)}
}

\newglossaryentry{dma}{
    type=\acronymtype,
    name={DMA},
    description={Direct Memory Access},
    first={Direct Memory Access (DMA)},
}

\newglossaryentry{dmg_g}{
    name={Dot Matrix Game},
    description={The model name of the Gameboy. It is often used to refer to the ``base'' Gameboy (in contrast with GBC for the Gameboy Color)}
}
\newglossaryentry{dmg}{
    type=\acronymtype,
    name={DMG},
    description={Dot Matrix Game},
    first={Dot Matrix Game (DMG)\glsadd{dmg_g}},
}

\newglossaryentry{tcyc}{
    name={T-Cycle},
    description={A T-cycle is the smallest step the internal clock of the Gameboy can do. This means the rate of T-cycle is that of the CPU, ie. 4.19Mhz}
}

\newglossaryentry{mcyc}{
    name={M-Cycle},
    description={An M-Cycle (or machine cycle) is the smallest step the CPU of the Gameboy can do. Because all instructions of the CPU are multiples of 4, instruction lengths and timings are usually referred to in M-cycles (e.g. \texttt{LD A, B} takes 4 T-cycles, thus 1 M-cycle)}
}

\newglossaryentry{mmap}{
    name={Memory Map},
    description={The memory map is what determines where each address leads to - it can be seen as a list of non-overlapping ranges}
}

\newglossaryentry{msb}{
    type=\acronymtype,
    name={MSB},
    description={Most Significant Bits},
    first={Most Significant Bits (MSB)},
}

% setup paragraph spacing
\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{-8pt}\relax
\titlespacing\subsection{0pt}{12pt plus 4pt minus 2pt}{-10pt}\relax
\titlespacing\subsubsection{0pt}{12pt plus 4pt minus 2pt}{-10pt}\relax

\begin{document}

% setup fonts

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        \textbf{Emmy: The Gameboy Color Emulator}\\
        6CCS3PRJ Final Project

        \vspace{1.5cm}
        \Large
        Classic video game console emulation

        \vfill

        Author: Oscar Sjöstedt\\
        Student ID: K20040078\\
        Supervisor: Ian Kenny

        \vspace{1.5cm}

        \Large
        Draft Two \\
        \today \\
        King's College London \\

    \end{center}
\end{titlepage}

\null\vfill

\clearpage

\vspace*{\fill}
\begin{center}
	I verify that I am the sole author of this report, \\
	except where explicitly stated  to the contrary.

	Oscar Sjöstedt, \today
\end{center}
\vspace*{\fill}

\begin{abstract}
    This project aims to create a Gameboy emulator web-application, in other words a program capable of receiving Gameboy game files (commonly refered to as ROMs), and interpreting such ROM to play the game (or execute the program) it contains. The emulator will be usable in browsers, for both desktop computers and mobile devices that may not have access to a physical keyboard. The emulator will also contain debugging capacities, to allow other emulator developers to use it when comparing with their emulator and working on it.

    The objective of this project is to create a piece of software that could be used by anyone wanting to emulate retro games, without the need for any technical knowledge on emulators or downloading anything (except the ROMs that need to be obtained separately).
\end{abstract}
\vfill

\clearpage

{\hypersetup{hidelinks}\tableofcontents}

\clearpage

\chapter{Introduction}

\section{Motivation}

Emulators are an area of computer science widely used today. Either implemented in hardware or software, they allow replicating the behaviour of one system on another. One of its applications is video game emulation, where a computer simulates a game console (usually a retro console). This allows users to play games that either may not be obtainable in stores anymore, or made for consoles that don't function properly anymore. A wide range of emulators already exist for most consoles. Emulation in general is also widely used in developing new systems, and is an active area of computer science.

This project will seek to create a new emulator for the Gameboy allowing users to play retro games on their computer or mobile device, through the browser. This report will document how the original console works and how the emulator imitates this behaviour to the best accuracy possible, as well as comparing the resulting emulator with other existing ones.

\section{Scope}

The scope of this project is creating a new Gameboy and Gameboy Color emulator, working for browsers. Emulation will be as accurate as achievable with the time available - there may be minor inacuracies in the end product. Extra peripherals and features of the console may be omitted, to allow more focus to be put on the core part of the console.

The emulator will be usable across a range of devices. Debugging tools and additional features may be provided to the user to let them customise their experience to their needs.

\section{Objectives}

The resulting software will allow users to open a game file for the gameboy - also called a ROM - and play it. They may use the emulator on a computer, controlling the console via the keyboard, or on a touch device, using on-screen buttons. The emulated features of the emulator include proper rendering of the screen, simulating the audio of the console, the different buttons, and support for a variety of chip controllers for game cartridges.

The frontend of the emulator may also contain additional quality of life features, such as custom themes, save states, and debugging options allowing to inspect the state of the Gameboy - a feature vital to emulator developers and retro game developers.

\chapter{Background}

\section{Emulation}

An emulator is ``hardware or software that permits programs written for one computer to be run on another computer'' \cite{emulator_def}. The imitated computer is the \textit{guest}, and the one that imitates is the \textit{host}. Emulators are nowadays mainly found in the form of software, and have many different uses, from preservation to hardware development.

Emulation was technically born with the first computers: the very first computer, the Colossus made in 1941, was built to imitate the Enigma machine \cite{emulator_origin}. However emulation was properly studied towards the end of the twentieth century, when computing power started to steadily increase. One of the earliest instances of emulation as an actual feature is with the IBM System/360. This computer supported emulation of previous models, such as the IBM 709, 7090, 7094 and 7094 II \cite{ibm_emulation}.

Nowadays emulation is used when researching and creating new hardware - using virtual systems to design a system and look for errors is much more cost-effective \cite{emu_in_design}. The real system doesn't have to actually be produced, and if something goes wrong it is very simple to look for the error in the simulated system, through logging or stepping through the simulation.

Emulation is also vital for preservation: as transistors and motherboards age, old systems become unusable, and with them the software they ran. Emulating these systems is often the only future-proof and sustainable way to keep this software usable.

Finally, another common use for emulation is virtual machines. These programs allow running another \gls{os} on a computer, which can be used for instance when developing for other systems, without needing to use the physical device directly, for instance when developing a Windows-compatible app with a Linux computer.

\section{Video Game Emulation}

Video game emulation is the art of emulation applied to video game hardware systems. This allows the host to run games destined for the original console. This usually requires precise understanding of the console's hardware and functioning, as games may rely on specific behaviours and edge cases to function. This task is rendered harder by the fact that often game consoles are poorly documented, as they are proprietary hardware and programmer guides written for them cannot be legally distributed.

Video game emulation started in the 90s when computers were powerful enough to properly simulate console systems. Although precise dates are hard to get, the first console emulators seem to be either from 1990 or 1993 \cite{first_nes_emu}, and were able to run some NES games. The first Gameboy emulators were in the late 90s, with the Virtual GameBoy\ftnt{http://fms.komkon.org/VGB/} in 1995 and NO\$GMB\ftnt{https://problemkaputt.de/gmb.htm} in 1997 (although it's history page\ftnt{https://problemkaputt.de/gmbhist.htm} seems to indicate development started in 1993) \cite{first_gb_emus}.

The original game files and assembled code for video games is copyrighted material, and is referred to as the \gls{rom} of the game. Although distributing these \glspl{rom} is usually illegal, there also exist copyright free \glspl{rom}: games created by developers that chose to license them under Creative Commons licenses, for instance. Websites such as Retro Veteran\ftnt{https://www.retroveteran.com/category/nintendo-game-boy-color/} host wide collections of legal \glspl{rom}.

\section{Gameboy, Gameboy Color}

The \gls{gb} is an 8-bit handheld video game console, released in 1989. It has a small $160 \times 144$ pixel screen, and has a Sharp LR35902 as its \gls{cpu}, clocked at 4.19MHz \cite[Specifications]{pandoc}. In 1998, the \gls{gbc} was then released. Seen as the successor of the \gls{gb}, it contains a screen of the same resolution, but supporting colour, from a palette of 32768 options (15 bits per color). It contains the same \gls{cpu} as its predecessor, a Sharp LR35902, with now two modes: a 4.19MHz mode and a 8.38MHz mode (double-speed mode). This allows the \gls{gbc} to be backwards compatible with most \gls{gb} games - there are a few exceptions to this, games that used hardware bugs of the original \gls{gb} that were fixed in the \gls{gbc}.

From an emulation perspective, the \glsdesc{gbc} can thus be seen as an extension of the Game Boy - it has an identical CPU (although with a toggle-able double speed mode), and most of the memory layout is identical. To keep the remaining of this document simple, if not stated, ``GB'' will refer to both the original \glsdesc{gb} and the \glsdesc{gbc}, as they are very similar. \gls{dmg} refers to the original \glsdesc{gb} model.

\section{Existing Literature}

\subsection{Gameboy Documentation}

The \glsdesc{gb} is one of the best documented consoles for emulation, and an array of resources exist to get started writing a new one. Some useful resources explaining it's behaviour are:

\begin{compactitem}
    \item Pandocs\ftnt{https://gbdev.io/pandocs/} is a technical reference of how the \gls{gb} works. It is extremely complete and covers a wide range of topics, so it is useful to get a global view of a problem. It is one of the most referenced pieces of literature on the console.
    \item GB CPU Instructions\ftnt{https://meganesu.github.io/generate-gb-opcodes/} is a table containing all instructions the \gls{gb} \gls{cpu} has, as well as information on the amount of cycles taken by the instruction, the bytes of memory used, the flags affected by the operation, and a description of the instruction.
    \item Gameboy Complete Technical Reference\ftnt{https://gekkio.fi/files/gb-docs/gbctr.pdf} (GBCTR) is an unfinished document that contains very detailed information on the \gls{cpu} and other components of the \gls{gb}. Although incomplete, it provides a much lower-level view of the details of the \gls{gb} (compared to Pandocs), making it useful to emulate very specific behaviour like the cycle-by-cycle timing of the CPU.
    \item GB dev wiki\ftnt{https://gbdev.gg8.se/wiki/} is a wiki containing additional information on the \gls{gb}, including guides to making games and explanations on some hardware quirks, and in particular a very precise description of the \gls{apu}.
\end{compactitem}

\subsection{Existing Emulators}

A wide range of emulators for the \gls{gb} and \gls{gbc} already exist, many of them being open-source. These are useful when developing a new emulator, to see how they work internally. For performance reasons they're usually written in compiled languages, such as C++ and Rust, but some interpreted language alternatives exist. These emulators include:

\begin{compactitem}
    \item Game Boy Crust\ftnt{https://github.com/mattbruv/Gameboy-Crust} is a simple \gls{gb} emulator written in Rust. It is quite incomplete but has a comprehensive structure, so it's a good project to first figure out how emulators work.
    \item AccurateBoy\ftnt{https://github.com/Atem2069/accurateboy} is a highly accurate emulator, in particular for its \gls{ppu} that has pixel-perfect accuracy.
    \item oxideboy\ftnt{https://github.com/samcday/oxideboy} is another \gls{gb} emulator written in Rust, that is much more complete and helpful for some edge cases.
    \item SameBoy\ftnt{https://github.com/LIJI32/SameBoy} is one of the most accurate open source \gls{gb} and \gls{gbc} emulators, written in C. It is much more technically complex but still useful to understand edge cases, especially since it is the emulator I use and compare mine with.
    \item Mooneye GB\ftnt{https://github.com/Gekkio/mooneye-gb} is a \gls{gb} research emulator written in Rust. It passes most of the Mooneye test ROMs, making it helpful when encountering issues with these tests.
    \item GameBoy-Online\ftnt{https://github.com/taisel/GameBoy-Online/} is a high-accuracy JavaScript emulator, that I used when unsure on how to interface the emulator with the browser (notably for the \gls{apu}).
    \item Gameboy.js\ftnt{https://github.com/juchi/gameboy.js/} is another JavaScript emulator. It is fairly simply and inaccurate, but is easily hackable. As such it's the emulator I used when starting the emulator, to compare mine with.
    \item rboy\ftnt{https://github.com/mvdnes/rboy} is an emulator written in Rust, that I used when developing the \gls{apu} to compare mine with, as it passes some test \glspl{rom} I struggled with.
\end{compactitem}

\subsection{Gameboy Test ROMs}
\label{sec:gb-test-roms}

A core set of resources to develop an emulator is the test \glspl{rom} for that console. These are valid source code for the console, that instead of playing a game will run a set of tests on the console. These tests are first written to pass on the physical console itself, and are then used to ensure they also pass on the emulator. This means issues in specific components can be easily diagnosed (so long as the rest of the emulator responsible for running the test \gls{rom} works itself). These test \glspl{rom} also have the advantage of being open source, meaning their source code can be referred to, to understand what they expect of the console.

An other advantage to using test \gls{rom} is that they tend to re-use the same framework across a given test suite to report results. This means the result of the test is usually logged somewhere in the console, and testing can easily be automated by inspecting specific registers/memory addresses, rather than having to store an ``expect result'' image for each test.

The test \glspl{rom} used for this project are:

\begin{compactitem}
    \item Blaarg test \glspl{rom}\ftnt{https://github.com/retrio/gb-test-roms/} are some of the most well-known and used \gls{gb} test \glspl{rom}. They include tests for the \gls{cpu}, the timings of instructions, and some other functionality.
    \item Mooneye test \glspl{rom}\ftnt{https://github.com/Gekkio/mooneye-test-suite} is a very complete test suite, that verifies most components of the \gls{gb}: \gls{cpu} instructions, memory timings of specific instructions, behaviour of \glspl{mbc}, timing of the \gls{oam} \gls{dma}, \gls{ppu} timings, timer timings, etc.
    \item Acid Test (\gls{dmg}\ftnt{https://github.com/mattcurrie/dmg-acid2}, \gls{gbc}\ftnt{https://github.com/mattcurrie/cgb-acid2}) is a test that verifies the \gls{ppu} of the \gls{gb} displays data properly (to line-rendering accuracy), for both \glsdesc{gb} and \glsdesc{gbc} displays.
    \item SameSuite\ftnt{https://github.com/LIJI32/SameSuite/} is a test suite that is valuable for its \gls{apu} tests: it uses the PCM12 and PCM34 registers exclusive to the \gls{gbc} to inspect the exact ouput of the \gls{apu} (whereas other test \glspl{rom} tend to inspect the on/off status of the channels, which is much less accurate).
\end{compactitem}

\chapter{Requirements and Specification}

\section{Requirements}

\subsection{User Requirements}

\begin{enumerate}[start=1,label=U\arabic*.]
    \item Run \glsdesc{gb} games to a satisfiable fidelity, with proper rendering and controls emulation.
    \item Run \glsdesc{gbc} games to a satisfiable fidelity, with proper rendering and controls emulation.
    \item Allow the user to run \gls{gb} and \gls{gbc} games for both a \glsdesc{gb} and a \glsdesc{gbc} (ie. allow using a \gls{gbc} for a \texttt{.gbc} file, and a \gls{gb} for a \texttt{.gb} file).
    \item Allow the user to save the state of the game, to continue their playthrough later. The state can simply be saved as a downloaded file, and re-uploaded later to continue the game.
    \item Allow the user to change the speed at which the game is played: double speed mode, half speed mode, etc.
    \item Have some debug functionality, to inspect the state of the console at any given time.
    \item Allow users to pause the console, and add breakpoints to stop execution at specific moments.
    \item Allow the user to switch between rendering modes (nearest-neighbour, LCD display, scale2, etc.)
    \item Allow the user to switch the colour palette of the \gls{dmg} emulation.
\end{enumerate}

\subsection{System Requirements}

\begin{enumerate}[start=1,label=F\arabic*.]
    \item The system can receive a \gls{rom} file, construct an instance of the emulated console, and run the code inside said \gls{rom}.
    \item The system emulates different components of the \gls{gb} and \gls{gbc}, with as much precision as possible (\gls{mcyc} precision).
    \item The system renders the output of the emulator to a Web \texttt{<canvas />}.
    \item The system creates the required DOM elements for the web-app, and updates them as needed.
    \item The system listens to key presses and releases to emulate controls through the keyboard.
    \item For touch devices, the system may render buttons to simulate the console's controls.
\end{enumerate}

\subsection{Non-Functional Requirements}

\begin{enumerate}[start=1,label=N\arabic*.]
    \item The emulator should be accessible on computers through a web browser equipped with a recent version of JavaScript.
    \item The emulator should be accessible on mobile devices through a web browser equipped with a recent version of JavaScript.
    \item The emulator should be accessible on computers through a standalone app.
    \item Maximise the tests passed by the emulator (see \nameref{sec:gb-test-roms})
    \item Have the code be well documented, allowing new-comers to the project and to \gls{gb} emulation to easily understand what is going on - if possible with links to relevant \glsdesc{gb} emulation resources.
\end{enumerate}


\section{Specification}


\begin{xltabular}{\textwidth}{|c|X|c|}
    \hline
    \textbf{Code} & \textbf{Specification} & \textbf{Importance}\\
    \hline\hline
    \endhead

    U1 & User can upload a \gls{gb} \gls{rom} file (\texttt{.gb}), and the emulator will run the game. The keyboard can be used to control the game, and the output is displayed. & High \\ \hline
    U2 & User can upload a \gls{gbc} \gls{rom} file (\texttt{.gbc}), and the emulator will run the game. The keyboard can be used to control the game, and the output is displayed. & Medium \\ \hline
    U3 & User can upload a \gls{gb} \gls{rom} file (\texttt{.gb}). The user can switch between a \gls{dmg} and a \gls{gbc} emulator. & Medium \\ \hline
    U4 & User can press a button to download a save of their game (or, alternatively, the save can be stored inside the browser with a technology like IndexedDB\ftnt{https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API}) & Low \\ \hline
    U5 & User can select the speed of emulation, to dynamically accelerate/decelerate the game. & Medium \\ \hline
    U6 & User can see debug information of the emulator. This information includes the current tileset, background map, time to draw a frame, and register information. & Low \\ \hline
    U7 & User can pause the console emulation through a button. They can also input conditions for which the console should break execution. & Low \\ \hline
    U8 & User can dynamically switch the rendering filter via a dropdown button. & Low \\ \hline
    U9 & User can dynamically switch the colour palette of the GameBoy via a dropdown button. & Low \\ \hline

    F1 & A \gls{rom} file can be uploaded, is transformed into an \texttt{UInt8Array} (because the \gls{gb} is an 8-bit system), and the appropriate object is created to run the code. & High \\ \hline
    F2 & Different components exists as different classes, respecting typical OOP principles such as encapsulation and inheritance when relevant. & High \\ \hline
    F3 & A \texttt{<canvas />} element is created, and is updated with the output of the emulator after every frame is drawn (ie. at the start of each VBlank mode). & High \\ \hline
    F4 & The Preact\ftnt{https://preactjs.com/} framework is used to handle the UI of the web-app. & High \\ \hline
    F5 & Listeners are added to the environment's \texttt{window} to listen to all key presses and releases. The emulator can then request for a control update, by reading the state of keys. & High \\ \hline
    F6 & If a touch device is detected, button are added to the UI and are used by the emulator as inputs. & Medium \\ \hline

    N1 & A deployed version of the web-app is accessible on a desktop browser and provides full functionality, via keyboard and mouse inputs. & High \\ \hline
    N2 & A deployed version of the web-app is accessible on a mobile device browser and provides full functionality, via touch controls. & Medium \\ \hline
    N3 & A downloadable version of the web-app can be used on a computer and provides full functionality, via keyboard and mouse inputs. & Low \\ \hline
    N4 & As many possible tests as possible should be passed, while ensuring previously passing tests don't start failing. & Medium \\ \hline
    N5 & Main methods and variables must be properly documented, and have links to appropriate online resources to documentation about said element. & High \\ \hline
\end{xltabular}

\chapter{Design}

In this chapter we will outline the main components of the Gameboy and of this emulator. For the different \gls{gb} components, we will briefly go over their role, and how they interact with other components and to what end.

In emulators, the different components are usually split in three parts:
\begin{compactitem}
	\item The \gls{cpu}, responsible for reading instructions and changing the state of the console. This is what drives the emulation, as other components usually idle unless acted upon.
	\item Input and output components, such as the \gls{apu}, the \gls{ppu} and the joypad. These components interact with the outside user, by either outputing the game state, or reading inputs from the user.
	\item A memory system, that handles addressing within the console. This part is essential to ensure components are communicating between each other properly, since different addresses may map to different components.
\end{compactitem}

Because the emulator should not rely on the environment it is running it to work, the functionality of the project can be split into two parts: the emulator core, that is responsible for simulating the Gameboy, and the emulator's frontend, that allows interfacing with the user, and may be changed to work for different platforms (see \ref{fig:emu-back-front-split-uml}).

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
    	\umlbasiccomponent[x=4]{EmulatorUI}
    	\umlbasiccomponent[y=3]{Gameboy}
    	\umlHVassemblyconnector[interface=EmulatorOut, with port]{EmulatorUI}{Gameboy}
    	\umlHVassemblyconnector[interface=EmulatorIn, with port]{Gameboy}{EmulatorUI}
    \end{tikzpicture}
    \caption{Split of emulator core and frontend}
    \label{fig:emu-back-front-split-uml}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics{diagrams/emulator-comp-diagram.drawio.pdf}
    \caption{Simplified design of the emulator's core}
    \label{fig:emu-core-components}
\end{figure}


\section{Emulator Frontend}

To allow the user to access the emulator, a frontend needs to be built with it. This frontend is responsible for outputting the graphics and audio data of the emulator, and also for receiving input from the user to pass down to the emulator. Aside from that, extra UI components have been added, to make the usage of the emulator more convenient and add more features: a play/pause button, custom themes, debugging tools, upscaling filters and keybinding options. All of these are kept independent from the emulator, and control transformations of the input/output, or changes in the running of the emulator.

Because this implementation is merely to allow access to the emulator and doesn't have any outstanding functionality, it's description will be brief - most of the focus will be put on the emulator's core.

\section{CPU}

The \glsfirst{cpu} is perhaps the most complex part of the \gls{gb}. It is however also one of best documented parts of it, making it quite easy to emulate properly. The \gls{cpu} model is a LR35902, which is a hybrid of the Intel 8080 chip and the Zilog Z80 \cite{gbcpumanual}.

Most emulator are typically ``CPU-driven''. This means that the \gls{cpu} is what drives the emulation. If an instruction takes multiple hardware cycles to execute, the \gls{cpu} is responsible for asking the rest of the system to tick at the appropriate time. In the design chosen for this project however, the emulator will be ``System-driven'', with the \gls{cpu} only being part of the overall running of the emulator, and will not be responsible for ticking the rest of the system. This difference will be made obvious by the interfaces exposed to the \gls{cpu}; it allows for nicer encapsulation and better separation of concerns.

The \gls{cpu} is thus responsible for stepping through the program it's given. It has 6 different 16-bit registers, with different roles. Some registers' bytes can be accessed independently, operating as two 8-bit registers or one 16-bit register as needed \cite[CPU Registers and Flags]{pandoc}.

\begin{compactitem}
	\item \texttt{AF}: the accumulator-flag register. Most arithmetic operations can be done on \texttt{A}. \texttt{F} holds the \gls{cpu}'s flags, and can only be altered through arithmetic opeartions.
	\item \texttt{PC}: the program counter register. It cannot be accessed directly, and is used to store the current position of the \gls{cpu} in the program. It can be altered via \texttt{CALL}, \texttt{RET}, \texttt{JP} operations, for instance.
	\item \texttt{SP}: the stack pointer register. It can be modified or incremented, and stores the pointer to the top of the ``stack''. A typical use of the stack is for handling functions, by pushing the current address to the stack whenever a procedure is called, and popping it back to the stack pointer when it returns.
	\item \texttt{BC}, \texttt{DE}: two simple registers that can be used for arithmetic operations.
	\item \texttt{HL}: similar to \texttt{BC} and \texttt{DE}, it can also be used as an address by some operations - allowing the use of indirect addressing.
\end{compactitem}

Aside from it's registers, the \gls{cpu} needs to interact with system interrupts, and needs to access memory for reading/writing operations.

% TODO: Keep this for implementation?
%
% Each opcode (operation code) of the \gls{gb} is one byte long, meaning there could be $2^8=256$ different opcodes. However, there exist 16-bit opcodes, to allow the \gls{cpu} to perform more operations. These 16-bit opcodes always start with \texttt{0xCB}, with the second byte containing what operation is executed. There are also 11 values of the opcode that do nothing, and aren't used in any \glspl{rom}. This brings the total number of operations to $2^8 * 2 - 11 = 245$.

\section{PPU, APU, Joypad}

The \glsfirst{ppu} is a complex part of the Gameboy, that handles outputting the game state to a $160 \times 144$ screen, that may either be monochrome on the \gls{dmg} or with color support on the \gls{gbc}. It may raise interrupts, and needs to be able to access memory, due to it being responsible for the \glsfirst{oam} - a feature allowing transfer of data from an arbitrary location in memory.

The \glsfirst{apu} is responsible for playing the audio output of the console. It has a few registers to control it, as well as a short memory area called the wave RAM. It is partially controlled by the timer, but is otherwise independent. It's sound output is derived from four separate channels: two square wave channels, a custom wave chanel, and a noise channel \cite[Audio]{pandoc}. These channels are here modelled as separate entities, but are purely internal.

The former two components need to output information to the user, either graphic or audio data. To do this in a portable way, the emulator will expose an interface, that can be implemented by the front-end. This allows the emulator core to be platform-agnostic, and be easily portable.

The joypad, on the other hand, is the one input component the \gls{gb} has. It contains 4 directional arrow buttons, and 4 input buttons: A, B, start and select (see \ref{fig:gb-front}). To use these inputs, the \gls{cpu} needs to use two different registers.

Similarly as for the output, the emulator core will expose an interface to read  the user's input, ie. the state of all 8 buttons.

\begin{figure}[h]
    \centering
    \includegraphics[width=4cm]{images/gameboy}\\
    \caption{Picture of a Gameboy, with the screen and joypad visible}
    \label{fig:gb-front}
\end{figure}

\section{Memory Bus}

Components withing the Gameboy need to communicate. To do this, components typically have a set of registers that control how they behave - for instance, the timer has a \texttt{TAC} register at \texttt{0xFF07} to control it's frequency. To allow this interaction without having all components directly depend on each other, a ``memory-bus'' component is created, responsible for handling all components and managing memory-addressing among them.

This component, called \texttt{System}, is thus responsible for instantiating the other components, and providing them access to eachother, via a read and write method.

\section{Other Components}

Aside from the aforementioned components, the \gls{gb} has a few components that allow it to run but aren't part of the \gls{cpu} or the input/output components. These will be briefly outlined here, as they have a lesser impact on the emulator's design.

\subsection{Timer}

The timer, responsible for incrementing a counter (the \texttt{DIV}) at a set frequency. It can raise interrupts, and owns a few registers.

\subsection{Interrupts}

The interrupt system, that allows components such as the timer or the \gls{ppu} to interrupt the \gls{cpu} to run another process. It can also be enabled and disabled by the \gls{cpu}, with the \texttt{EI} and \texttt{DI} instructions.

This sub-system is designed as a separate component to reduce coupling between other components, and instead have a small object that can be passed to components as needed.

\subsection{MBC}

The \glsfirst{mbc} is an extra chip contained within some game cartridges, to allow access to more \gls{rom} data (as well as external RAM in some cases) via banking \cite[MBCs]{pandoc}. There are multiple different \glspl{mbc}, and so it is convenient to define a common interface for all of them, which can then be implemented according to specification for each \gls{mbc} type.

The type of the \gls{mbc} is in the header of the \gls{rom} \cite[The Cartridge Header]{pandoc}. To separate this logic from the base system, a \texttt{ROM} class is used. It is responsible for reading the cartidge's header, and creating the appropriate \gls{mbc} instance.

\section{Useful Classes}

To have similar interfaces over all components, we will also declare specific classes and interfaces to be implemented by them.

\subsection{Addressable}

The \texttt{Addressable} interface provides a read and write method. This allows all components to communicate between each other without needing to be aware of what the component they're communicating with is. Aside from the \gls{cpu}, all components of the emulator implement this method.

\subsection{Memory and registers}

Simple utility classes can be declared to manage memory in a simple way.

The \texttt{RAM} class implements \texttt{Addressable}. It can be instantiated with a set size, and can be read and written to. It is used in components that have large blocks of writable data.

The \texttt{Register} class implements \texttt{Addressable}, but ignores the address parameter of the read and write operations, as it contains only one byte. A \texttt{DoubleRegister} class may also be implemented, backed by two \texttt{Register}s, to provide support for 16-bit registers, used for instance in the \gls{cpu}.

\chapter{Implementation}

The project uses Preact\ftnt{https://preactjs.com/}, a light-weight alternative to the more popular React\ftnt{https://reactjs.org/} framework. Preact was chosen because the front-end of the web-app is extremely lightweight, so a smaller framework with less features is enough. This also avoids bloating the app with a heavy framework such as React: its GZipped and minified size is around 31.8Kb, while Preact is only 4Kb (87\% less).

The language used for the project is TypeScript\ftnt{https://www.typescriptlang.org/}, a typed version of JavaScript. This is essential for the project, as ensuring the correctness of code can be extremely hard without proper typing constraints, especially as a project grows in size.

The project is divided into two parts:
\begin{compactitem}
    \item The \texttt{frontend/} directory contains the UI for the web-app. The main logic to create the emulator and run it is contained in \texttt{app.tsx}.
    \item  The \texttt{emulator/} directory contains the actual \gls{gb} emulator. Although most classes and interfaces used are exported, only three elements are needed to properly interact with the emulator:
    \begin{compactitem}
        \item \texttt{GameBoyColor.ts} handles the core loop of the system. It contains the \texttt{GameBoyColor} class, the emulator. Instantiating the emulator creates all the necessary sub-components, and calling the \texttt{drawFrame()} method runs the emulator for one frame (0.16 seconds).
        \item \texttt{GameBoyOutput.ts} contains a simple interface, with optional methods to receive any output produced by the emulator (see figure \ref{fig:gameboyoutput}). The two main methods of this are \texttt{receiveGraphics} and \texttt{receiveSound}, which use the output of the actual console.
        \item \texttt{GameBoyInput.ts} contains a simple interface with a required \texttt{read()} method that returns an object with the current inputs for the console (see figure \ref{fig:gameboyinput}).
    \end{compactitem}
\end{compactitem}

\begin{figure}[h]
    \begin{minted}{typescript}
interface GameBoyOutput {
    receiveGraphics?(data: Uint32Array): void;
    receiveSound?(data: Float32Array): void;

    // Debugging methods:
    debugBackground?(data: Uint32Array): void;
    debugTileset?(data: Uint32Array): void;
    serialOut?(data: number): void;
    stepCount?(steps: number): void;
    cyclesPerSec?(cycles: number): void;
    frameDrawDuration?(ms: number): void;
}
    \end{minted}
    \caption{\texttt{GameBoyOutput} interface methods}
    \label{fig:gameboyoutput}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
type GameBoyInputRead = {
    up: boolean;
    down: boolean;
    left: boolean;
    right: boolean;

    a: boolean;
    b: boolean;
    start: boolean;
    select: boolean;
};

interface GameBoyInput {
    read(): GameBoyInputRead;
}
    \end{minted}
    \caption{\texttt{GameBoyInput} interface method}
    \label{fig:gameboyinput}
\end{figure}

\section{Emulator Frontend}

The frontend of the emulator is written in Preact, allowing us to create a simple, fast and lightweight UI to control it. It contains the emulator title, the control buttons and the emulator video output (see figure~\ref{fig:emmy-home}). Along the left of the screen is a sidebar with more options, allowing the user to customise the emulator to their needs and debug the state of the console if needed.

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/emmy-home-page}\\
    \caption{Home page of the emulator}
    \label{fig:emmy-home}
\end{figure}

\subsection{Main Controls}

The main controls for the emulator are the 6 buttons above the screen. These are, from left to right:

\begin{compactitem}
    \item Pause/play: pauses or resumes the emulator.
    \item Step by one \gls{cpu} instruction: this is a feature useful for debugging the emulator, when precise information of the state of the emulator is needed.
    \item Sound toggle: allows enabling or disabling the sound of the emulator. By default the sound is turned off, because modern browsers don't allow websites to play any sound before the user interacts with the website \cite{browser_autoplay}.
    \item Triple speed toggle: a toggle button that speeds up the emulator to emulate the \gls{gb} thrice as fast as usual. This is a common feature found in most emulators.
    \item Save state: saves the current state of the cartridge in the browser's storage, allowing the user to resume playing the game later. Note this doesn't save the full state of the emulator, but that of the cartridge, making it equivalent to a real-life save on the \gls{gb} where only the battery-backed storage of the cartridge persists through power-offs.
\end{compactitem}

\subsection{Settings}

In the side drawer, the first tab is ``Settings''. It contains general settings for the emulator, such as:

\begin{compactitem}
	\item the console used by the emulator. This may either be the \gls{dmg} or the \gls{gbc}.
	\item an extra filter to be applied to the output. This increases the resolution of the screen, using the Scale2x or Scale4x\ftnt{https://www.scale2x.it/} algorithm (see \ref{fig:scale-filter}).
	\item the size of the emulator's screen, allowing resizing to two or four times larger.
	\item a slider to change the volume of the emulator's audio output.
	\item a palette selector, to change the four hues of the \gls{dmg}'s screen.
	\item miscellaneous togglable settings, grouped together: 
	\begin{compactitem} 
		\item an option to play with or without the initial boot \gls{rom} of the emulator.
		\item a toggle to enable frame-blending, meaning for every new frame the output is mixed with the previous frame. This is a nice addition to have, because certain games made certain objects flicker on screen to make them appear translucent (since the flicker wasn't visible to the eye).
		\item a button to show the performance statistics of the emulator. This is mainly useful when developing the emulator to make sure it is still efficient.
		\item a toggle to enable the debug view of the emulator, where the currently loaded tileset and background map are displayed (see \ref{fig:debug-view}).
	\end{compactitem}
\end{compactitem}

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/scale-filter}\\
    \caption{Output of the \gls{gbc} with, from left to right: no filter, Scale2x and Scale4x}
    \label{fig:scale-filter}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{images/debug-view}\\
    \caption{Debug view of the emulator}
    \label{fig:debug-view}
\end{figure}

\subsection{Watch Expressions}

The second drawer allows the user to define custom JavaScript functions to inspect the state of the emulator regularly (see \ref{fig:watch-expressions}). This requires knowledge of the inner structure of the emulator, as the field names need to be used, but is quite useful when needing to inspect parts of the console that aren't the memory, like internal counters used for components, or register values. 

To implement this, the \texttt{Function}\ftnt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function} constructor is used, which takes in a string with the function's code. This allows the user to dynamically change the expression, and the component will simply update the function, without needing to reload the whole application. These expressions are also automatically saved to \texttt{localStorage}\ftnt{https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}, meaning they will be kept between sessions.

The user-defined function is then repeatedly invoked, and the result output below the expression, allowing for a live-status of the emulator. If an error is thrown by the function (due to a null value, or invalid expression), the error is caught and `\texttt{Error}' is displayed.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/watch-expressions}\\
    \caption{Watch expressions drawer}
    \label{fig:watch-expressions}
\end{figure}

\subsection{Test ROMs}

To ensure emulators work properly, a variety of test \glspl{rom} have been made, that test most aspects of the \gls{gb} (see \ref{sec:gb-test-roms}). The front-end of the emulator supports running a large number of them in an automated way (see \ref{fig:}). The user can select the group of tests desired, and they will run internally (without receiving any input our outputting anything directly). The status of each individual test is displayed, and the user can click on the test name to run it on the main emulator, for further debugging or inspection.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/test-roms}\\
    \caption{Test \glspl{rom} drawer}
    \label{fig:watch-expressions}
\end{figure}

To run the tests, an emulator instance is created, with the test \gls{rom} as the input data and ``spy'' objects provided for input and output - these spies store the output of the emulator, to evaluate the state of the test. To stop execution, the emulator's state is inspected regularly, and the outcome of the test is checked (with execution terminating if the test takes too long to end).

To detect the outcome of each test, these are grouped according to what test suite they belong to. Each test suite is then associated to a \textit{success function}, that can either return \texttt{"success"}, \texttt{"failure"} or \texttt{null} if no outcome has been reached yet. As such, all tests in a test suite have a similar way of reporting success and failure.

The currently automated test suites are:
\begin{compactitem}
	\item The Blaarg test \glspl{rom}\ftnt{https://github.com/retrio/gb-test-roms}. The success function of this suite is quite complex, as this suite doesn't have a standard way of outputting the result. As such multiple parts of the emulator are inspected simultaneously:
		\begin{compactitem}
			\item \texttt{"Passed"}\footnote{See lines 50-54 of \texttt{mem\_timing/source/common/testing.s} in \url{https://github.com/retrio/gb-test-roms}} and \texttt{"Failed"}\footnote{See lines 112-139 of \texttt{mem\_timing/source/common/runtime.s} in \url{https://github.com/retrio/gb-test-roms}} may be output to the console's serial port.
			\item If the memory at \texttt{0xa001-0xa003} is equal to \texttt{0xdeb061}, then the byte stored at \texttt{0xa000} is the status of the test\footnote{See `Output to memory' in \texttt{dmg\_sound/readme.txt} of \url{https://github.com/retrio/gb-test-roms}}.
			\item For the \texttt{halt\_bug} test, there doesn't seem to be anywhere where the result is output, so the graphical output of the emulator is verified.
		\end{compactitem}
	\item The Mooneye test \glspl{rom}\ftnt{https://github.com/Gekkio/mooneye-test-suite} and SameSuite\ftnt{https://github.com/LIJI32/SameSuite/}, of which all tests are verified the same way. In case of success, the \texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{H} and \texttt{L} registers hold the values $3$, $5$, $8$, $13$, $21$ and $34$ respectively (Fibonacci's sequence). If they instead all hold the value \texttt{0x42}, the test failed\footnote{See \url{https://github.com/Gekkio/mooneye-test-suite/\#passfail-reporting} for the Mooneye test suite, see lines 265-281 of \texttt{include/base.inc} in \url{https://github.com/LIJI32/SameSuite/} for the SameSuite}.
	\item The Acid test \glspl{rom} (\gls{dmg}\ftnt{https://github.com/mattcurrie/dmg-acid2}, \gls{gbc}\ftnt{https://github.com/mattcurrie/cgb-acid2}). These need to be tested graphically, as their purpose is verifying the actual output of the emulator rather than it's behaviour.
\end{compactitem}

Thanks to this, the emulator's frontend supports a total of 191 automated test \glspl{rom}, that verify the behaviour of most of the emulator. Of these 191 tests, 101 pass.

\subsection{Memory Inspect}

When debugging an emulator, being able to inspect it's memory is essential, as some bugs may be caused by the wrong mapping of components, or a fault when writing data. To help debugging this, the frontend comes with a basic memory inspection tool, that can show the entirety of the \textit{addressable} data of the emulator (see \ref{fig:memory-inspect}). This means data that is not accessible by the game (for instance, because the appropriate \gls{rom} bank is not selected) cannot be inspected here. A simple offset can also be indicated, to restrain the data to a certain area.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/memory-inspect}\\
    \caption{The memory inspection drawer}
    \label{fig:memory-inspect}
\end{figure}

\subsection{Keybindings}

The user can also customise their keybindings for the emulator, by mapping each input to a separate key (see \ref{fig:keybindings}). This is only relevant on keyboard-equipped devices.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/keybindings}\\
    \caption{The keybindings settings}
    \label{fig:keybindings}
\end{figure}

\section{Emulator Backend}

To keep the logic of the hardware, divided in different components, the structure of the emulator has a similar format, with different classes implementing the behaviour of the different parts of the \glsdesc{gb}.

\subsection{Addressable}

The \texttt{Addressable} interface is implemented by most classes of the emulator: \texttt{System}, \texttt{Register}, \texttt{MBC}, etc. It is simple, and provides a read and a write method (see figure \ref{fig:addressable}). The advantage of using it is that when implementing adressing logic with large switch-statements I can simply return any type of components that adheres to the interface, and the receiving method is agnostic of if it's dealing with a register, memory, or a component.

\begin{figure}[h]
    \begin{minted}{typescript}
interface Addressable {
    read(pos: number): number;
    write(pos: number, data: number): void;
}
    \end{minted}
    \caption{\texttt{Addressable} interface method}
    \label{fig:addressable}
\end{figure}

\subsection{System}

The \texttt{System} class implements the motherboard, and the general connection between elements. It handles the ticking of the \gls{ppu}, timer and \gls{oam} \gls{dma}. Furthermore, it is the component that links all of the data together: whenever a component is ticked (any of the above or the \gls{cpu}), the \texttt{System} instance is passed, so that the components can read and write to the rest of the system. It does implement \texttt{Addressable}, and internally has a \texttt{getAdress} method that returns both an \texttt{Addressable} and a number (the index to read or write to). This way the addressing logic to determine what component is accessed depending on the address isn't duplicated.

\subsubsection{\texttt{getAddress} optimisation}

Because \texttt{System} is a higly used component and is accessed for almost every read and write, the \texttt{getAddress} method is under a lot of pressure. As such, it was the source of a major re-write during development, which improved performances significantly.

Initially it was implemented as a list of if-statements for different ranges of the \gls{mmap}, as well as an object where the keys were different register-addresses. The code would first check if the key exists in the register object (it thus served as a map), and if not it would then go through a series of if-conditions (see figure \ref{fig:getaddress-before}).

This proved quite costly, for three main reasons:
\begin{compactitem}
    \item This code creates a new object every time it is called, when checking for the registers' addresses.
    \item The if-conditions for the ranges of the biggest areas of memory (everything between \texttt{0x0000} and \texttt{0xffef}) happened after the register checks, which delayed response for these reads and writes.
    \item Chaining if-conditions is unneficient, as the JS engine must step through all conditions and check the values each time. Furthermore, although having both the lower and upper bound of the memory section indicated in the condition (e.g. \texttt{0x0000 <= pos \&\& pos <= 0x7fff} for $[\texttt{0x0000}; \texttt{0x7fff}]$) makes the translation from \gls{mmap} to code easier, it is slower, since only the upper bound of the range is needed for the condition \textit{if} all the ranges below have already returned.
\end{compactitem}

My intial optimisation - and the one that had the most impact on this method - was fixing the last two points: removing these if-conditions, and moving these areas higher in the code.

The way the addressing circuitry works is that addresses are not compared in their entirety: the circuit checks for small sections of the address, and then maps those to more precise locations. As such the main areas of memory can usually be identified by their \gls{msb} - usually the most significant nybble (see figure \ref{fig:memory-map-largest}).

\begin{figure}[h]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Start} & \textbf{End} & \textbf{Description} \\ \hline
    0000 & 3FFF & 16 KiB ROM bank 00 \\ \hline
    4000 & 7FFF & 16 KiB ROM Bank 01$\sim$NN \\ \hline
    8000 & 9FFF & 8 KiB Video RAM (VRAM) \\ \hline
    A000 & BFFF & 8 KiB External RAM \\ \hline
    C000 & CFFF & 4 KiB Work RAM (WRAM) \\ \hline
    D000 & DFFF & 4 KiB Work RAM (WRAM) \\ \hline
    \end{tabular}\\
    Source: Pandocs\ftnt{https://gbdev.io/pandocs/Memory_Map.html}
    \caption{Memory map for the largest chunks of memory}
    \label{fig:memory-map-largest}
\end{figure}

This means that for this area of memory we can simply isolate the last nybble, and then create a switch-statement over it to map directly to specific areas. This removes the need for the if-conditions, and is also faster as it is evaluated much earlier on (see figure \ref{fig:getaddress-after}).

I then ran a simple test to verify the performance improvement. I ran the first 25 million instructions of the \texttt{cpu\_instrs}\ftnt{https://github.com/retrio/gb-test-roms/tree/master/cpu_instrs} test \gls{rom} - I chose this sample because it is considerably large, because the test itself requires around 25 million instructions to complete, and because this test checks for all instructions of the \gls{cpu}, meaning that it exercices most configurations of the \gls{cpu} and system. For the measurement, I used \texttt{window.performance.now()} before and after each drawn frame, and summed the values.

The result was the following: $33 955.9$ms before the change, and $20 039.1$ after the change. The relative difference is thus $\frac{20 039.1-33 955.9}{33 955.9}=-0.4098$, thus reducing time taken by $40.98\%$.

Note that, although this may vary based on engine, switch statements aren't faster than if-conditions in JavaScript. This simple test-suite\ftnt{https://jsbench.me/qqlbqix93t/1} has a switch statement with 16 cases, along with an object with 16 keys and an if-statement with 16 clauses. On my browser (Google Chrome v108), the switch-statement proved the fastest, with the switch and if statements lagging behind by being respectively $69.81\%$ and $70.23\%$ slower. As such I suspect this improvement to be mainly due to the switch statement being moved at the beginning of the function, thus skipping the more expensive object creation.

This also means that improvements to this method can still be done. Using the ``Performance'' tab of Chrome Developer Tools, I measured the performance of the whole emulator when running the first 10 million instructions of this same test. The results I got indicated that \texttt{getAddress} is still the third method with the higest \textbf{self-time} (see figures \ref{fig:performance-getaddress-before} and \ref{fig:performance-getaddress-after}). Here self-time refers to the time taken inside the method itself, and total time is the time taken by the method and the methods it calls. Note how \texttt{getAddress} still has the third highest self-time, meaning that the content of the method itself takes time (although this value dropped from $40.7\%$ to $7.7\%$). The increase is self-time percentage (not time!) for all other methods is simply due to the fact that by making \texttt{getAddress} faster the self-time of these other methods (that all call \texttt{getAddress}) gets proportionally higher compared to their total time.

\begin{figure}[h]
    \centering
    \includegraphics[width=8cm]{images/get-address-before}\\
    \caption{Performance measurement of the emulator before \texttt{getAddress} optimisation}
    \label{fig:performance-getaddress-before}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=8cm]{images/get-address-after}\\
    \caption{Performance measurement of the emulator after \texttt{getAddress} optimisation}
    \label{fig:performance-getaddress-after}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
protected getAddress(pos: number): AddressData {
    if (pos < 0x0000 || pos > 0xffff)
        throw new Error(`Invalid address to read from ${pos.toString(16)}`);

    const register = {
        0xff00: this.joypad,
        ...
        0xffff: this.intEnable,
    }[pos];
    if (register !== undefined) return [register, pos];

    if (0x0000 <= pos && pos <= 0x7fff) return [this.rom, pos]; // ROM Bank
    ...
    if (0xfe00 <= pos && pos <= 0xfe9f) return [this.oam, pos]; // OAM

    // Unmapped area, return 'fake' register
    return [{ read: () => 0xff, write: () => {} }, 0];
}
    \end{minted}
    \caption{Initial implementation of \texttt{getAddress}}
    \label{fig:getaddress-before}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
protected getAddress(pos: number): AddressData {
    if (pos < 0x0000 || pos > 0xffff)
        throw new Error(`Invalid address to read from ${pos.toString(16)}`);

    switch ((pos >> 12) as Int4) {
        case 0x0:
            return [this.rom, pos]; // ROM
        ...
        case 0xe:
            return [this.wram, pos & (WRAM_SIZE - 1)]; // ECHO RAM
        case 0xf:
            break; // fall through - ECHO RAM + registers
    }

    const register = {
        0xff00: this.joypad,
        ...
        0xffff: this.intEnable,
    }[pos];
    ... rest is unchanged
}
    \end{minted}
    \caption{Optimised implementation of \texttt{getAddress}}
    \label{fig:getaddress-after}
\end{figure}

\clearpage
\subsection{CPU}

The \gls{cpu} is the most important part of the emulator, and allows running the code from the \gls{rom} by reading the operation code (or opcode) and executing the matching action.

\subsubsection{Initial Instruction Set}

Because the \glsdesc{gb} is an 8-bit system, opcodes are 8 bits (or one byte) long, giving in theory a maximum of $2^8=256$ operations. However in the \gls{gb} the operation \texttt{0xCB} gives access to an extended instruction set, meaning that when reading \texttt{0xCB} the \gls{cpu} will read the next byte and use a different logic to execute the operation. This means there are now $2^8 - 1 + 2^8=511$ operations. The \gls{gb} also has 11 forbidden opcodes (the console will lock itself if they are executed), meaning there are in total $2^8 - 12 + 2^8 = 500$ operations to implement.

Multiple techniques exist to handle this large number of operations:

\begin{compactitem}
    \item Have a large switch-statement for all operations
    \item Have a map, that maps an opcode to a function to execute
    \item Decode the operation by reading specific parts of the byte, and generate the instructions dynamically
\end{compactitem}

I initially had a large object, with all the opcodes as keys, that would then contains a simple function that returns the number of cycles taken by the instruction (see figure \ref{fig:instset-first}). This however proved quite repetitive and prone to errors. Furthermore, this wasn't \gls{mcyc} accurate: the \gls{cpu} instruction was executed as one monolithic block, when in reality all reads and writes are executed at a separate \gls{mcyc} - this becomes very important when the timer, \gls{oam} and \gls{ppu} are involved, as they run in parallel with the \gls{cpu}, so memory accesses to these components may return different values depending on the \gls{mcyc}.

\begin{figure}[h]
    \begin{minted}{typescript}
protected instructionSet: Partial<Record<number, InstructionObject>> = {
    // NOP
    0x00: () => 1,
    // LD BC/DE/HL/SP, d16
    0x01: (s) => { this.regBC.set(this.nextWord(s)); return 3; },
    0x11: (s) => { this.regDE.set(this.nextWord(s)); return 3; },
    0x21: (s) => { this.regHL.set(this.nextWord(s)); return 3; },
    0x31: (s) => { this.regSP.set(this.nextWord(s)); return 3; },
    // INC BC/DE/HL/SP
    0x03: () => { this.regBC.inc(); return 2; },
    0x13: () => { this.regDE.inc(); return 2; },
    0x23: () => { this.regHL.inc(); return 2; },
    0x33: () => { this.regSP.inc(); return 2; },
    ...
}
    \end{minted}
    \caption{Initial instruction set implementation}
    \label{fig:instset-first}
\end{figure}

\subsubsection{Becoming M-Cycle accurate}

In most (if not all) emulators I looked, the way \gls{mcyc} accuracy is reached is by making the emulator \textbf{\gls{cpu}-driven}. What this means is that inside each instruction, between each \gls{mcyc}, the \gls{cpu} is responsible for ticking the rest of the system - the main loop is then only responsible for continuously running the \gls{cpu}, and nothing else. This approach is probably the simplest and most straightforward one, as it is quite simple to implement - all one needs to do is call the system tick method when relevant (see figure \ref{fig:cpu-driven-ld}) .

\begin{figure}[h]
    \begin{minted}{typescript}
protected ld_bc_hl(system: System) { // LD BC, (HL)
    const lower = system.read(this.regPC.inc());
    system.tick();
    const upper = system.read(this.regPC.inc());
    system.tick();
    this.regBC.set(upper << 8 | lower);
}
    \end{minted}
    \caption{CPU-driven \texttt{LD BC, (HL)}}
    \label{fig:cpu-driven-ld}
\end{figure}

Because this was already done in most emulators, I wanted to try another idea I had, that I hadn't seen anywhere else: keep the emulator ``system-driven'', and instead make the \gls{cpu} remember what state and \gls{mcyc} it's on and what micro-instruction it must execute next.

This was done by splitting all the instructions into smaller chunks, that return each other, as arrow-functions. The \gls{cpu} now must simply store whatever the instruction returns: if it's \texttt{null} then it needs to fetch an instruction at the next cycle, otherwise it's a function and must be executed (and it's result stored for the next step). An advantage of this method is that the \gls{cpu} is still only responsible for executing instructions - it only needs the system to read/write to memory. See figures \ref{fig:system-driven-ld} and \ref{fig:system-driven-cpu-tick} for an example of this.

\begin{figure}[h]
    \begin{minted}{typescript}
protected ld_bc_hl(system: System) { // LD BC, (HL)
    const lower = system.read(this.regPC.inc());
    return () => {
        const upper = system.read(this.regPC.inc());
        return () => {
            this.regBC.set(upper << 8 | lower);
            return null;
        }
    }
}
    \end{minted}
    \caption{System-driven \texttt{LD BC, (HL)}}
    \label{fig:system-driven-ld}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
step(system: System) {
    if (this.nextStep === null) {
        // Execute next instruction
        const opcode = this.nextByte(system);
        const instruction = this.instructionSet[opcode];
        this.nextStep = instruction;
    }
    this.nextStep = this.nextStep(system);
}
    \end{minted}
    \caption{System-driven step of the \gls{cpu}}
    \label{fig:system-driven-cpu-tick}
\end{figure}

\subsection{Timer}
\subsection{PPU}
\subsection{OAM and OAM DMA}
\subsection{APU}
\subsection{MBCs and ROMs}

\chapter{Evaluation}


\clearpage

\printnoidxglossary[type=\acronymtype]
\printnoidxglossary[type=main]

\printbibliography


\end{document}
