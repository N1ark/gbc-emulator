\documentclass[11pt]{report}

\usepackage[a4paper,margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{multicol}
\usepackage{tabularx}
\usepackage{adjustbox}
\usepackage[acronym,toc,nonumberlist,nogroupskip]{glossaries}
\usepackage{enumitem}
\usepackage{xltabular}
\usepackage{dirtree}
\usepackage{minted}
\usepackage{standalone}

\usepackage{tikz}
\usepackage{tikz-timing}
\usepackage{packages/tikz-uml}


% setup bibliography
\usepackage[style=ieee]{biblatex}
\addbibresource{references.bib}

% setup hyperlinks
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=black,
    linkcolor=blue,
    urlcolor=blue,
}

% setup debug box command for places things are missing
\newcommand{\todo}[1]{\fbox{\parbox{\textwidth}{\textbf{TO-DO:} #1}}}

% add footnotes without the \footnote{\url{...}} command
\newcommand{\ftnt}[1]{\footnote{\url{#1}}}

% Glossary entry
\makenoidxglossaries

\newglossaryentry{ppu_g}{
    name={Picture Processing Unit},
    description={The part of the Gameboy that is responsible for rendering the game}
}
\newglossaryentry{ppu}{
    type=\acronymtype,
    name={PPU},
    description={Picture Processing Unit},
    first={Picture Processing Unit (PPU)\glsadd{ppu_g}},
}

\newglossaryentry{gb}{
    type=\acronymtype,
    name=GB,
    description={Gameboy},
    first={Gameboy (GB)}
}

\newglossaryentry{gbc}{
    type=\acronymtype,
    name=GBC,
    description={Gameboy Color},
    first={Gameboy Color (GBC)}
}

\newglossaryentry{os}{
	type=\acronymtype,
	name=OS,
	description={Operating System},
	first={Operating System (OS)}
}

\newglossaryentry{cpu}{
    type=\acronymtype,
    name=CPU,
    description={Central Processing Unit},
    first={Central Processing Unit (CPU)}
}

\newglossaryentry{apu_g}{
    name={Audio Processing Unit},
    description={The part of the Gameboy that is responsible with processing the game's audio}
}

\newglossaryentry{apu}{
    type=\acronymtype,
    name=APU,
    description={Audio Processing Unit},
    first={Audio Processing Unit (APU)}
}

\newglossaryentry{rom}{
    type=\acronymtype,
    name={ROM},
    plural={ROMs},
    description={Read-Only Memory},
    first={Read-Only Memory (ROM)},
    firstplural={Read-Only Memory (ROM)}
}

\newglossaryentry{mbc}{
    type=\acronymtype,
    name={MBC},
    plural={MBCs},
    description={Memory Bank Controller},
    first={Memory Bank Controller (MBC)},
    firstplural={Memory Bank Controllers (MBCs)}
}

\newglossaryentry{oam}{
    type=\acronymtype,
    name={OAM},
    description={Object Attribute Memory},
    first={Object Attribute Memory (OAM)},
}

\newglossaryentry{vram}{
	type=\acronymtype,
	name={VRAM},
	description={Video RAM},
	first={Video RAM (VRAM)}
}

\newglossaryentry{wram}{
	type=\acronymtype,
	name={WRAM},
	description={Work RAM},
	first={Work RAM (WRAM)}
}

\newglossaryentry{dma}{
    type=\acronymtype,
    name={DMA},
    description={Direct Memory Access},
    first={Direct Memory Access (DMA)},
}

\newglossaryentry{dmg_g}{
    name={Dot Matrix Game},
    description={The model name of the Gameboy. It is often used to refer to the ``base'' Gameboy (in contrast with GBC for the Gameboy Color)}
}
\newglossaryentry{dmg}{
    type=\acronymtype,
    name={DMG},
    description={Dot Matrix Game},
    first={Dot Matrix Game (DMG)\glsadd{dmg_g}},
}

\newglossaryentry{tcyc}{
    name={T-Cycle},
    description={A T-cycle is the smallest step the internal clock of the Gameboy can do. This means the rate of T-cycle is that of the CPU, ie. 4.19Mhz}
}

\newglossaryentry{mcyc}{
    name={M-Cycle},
    description={An M-Cycle (or machine cycle) is the smallest step the CPU of the Gameboy can do. Because all instructions of the CPU are multiples of 4, instruction lengths and timings are usually referred to in M-cycles (e.g. \texttt{LD A, B} takes 4 T-cycles, thus 1 M-cycle)}
}

\newglossaryentry{mmap}{
    name={Memory Map},
    description={The memory map is what determines where each address leads to - it can be seen as a list of non-overlapping ranges}
}

\newglossaryentry{msb}{
    type=\acronymtype,
    name={MSB},
    description={Most Significant Bits},
    first={Most Significant Bits (MSB)},
}

% setup paragraph spacing
\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{-8pt}\relax
\titlespacing\subsection{0pt}{12pt plus 4pt minus 2pt}{-10pt}\relax
\titlespacing\subsubsection{0pt}{12pt plus 4pt minus 2pt}{-10pt}\relax

\begin{document}

% setup fonts

\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \Huge
        \textbf{Emmy: The Gameboy Color Emulator}\\
        6CCS3PRJ Final Project

        \vspace{1.5cm}
        \Large
        Classic video game console emulation

        \vfill

        Author: Oscar Sjöstedt\\
        Student ID: K20040078\\
        Supervisor: Ian Kenny

        \vspace{1.5cm}

        \Large
        Draft Two \\
        \today \\
        King's College London \\

    \end{center}
\end{titlepage}

\null\vfill

\clearpage

\vspace*{\fill}
\begin{center}
	I verify that I am the sole author of this report, \\
	except where explicitly stated  to the contrary.

	Oscar Sjöstedt, \today
\end{center}
\vspace*{\fill}

\begin{abstract}
    This project aims to create a Gameboy emulator web-application, in other words a program capable of receiving Gameboy game files (commonly refered to as ROMs), and interpreting such ROM to play the game (or execute the program) it contains. The emulator will be usable in browsers, for both desktop computers and mobile devices that may not have access to a physical keyboard. The emulator will also contain debugging capacities, to allow other emulator developers to use it when comparing with their emulator and working on it.

    The objective of this project is to create a piece of software that could be used by anyone wanting to emulate retro games, without the need for any technical knowledge on emulators or downloading anything (except the ROMs that need to be obtained separately).
\end{abstract}
\vfill

\clearpage

{\hypersetup{hidelinks}\tableofcontents}

\clearpage

\chapter{Introduction}

\section{Motivation}

Emulators are an area of computer science widely used today. Either implemented in hardware or software, they allow replicating the behaviour of one system on another. One of its applications is video game emulation, where a computer simulates a game console (usually a retro console). This allows users to play games that either may not be obtainable in stores anymore, or made for consoles that don't function properly anymore. A wide range of emulators already exist for most consoles. Emulation in general is also widely used in developing new systems, and is an active area of computer science.

This project will seek to create a new emulator for the Gameboy allowing users to play retro games on their computer or mobile device, through the browser. This report will document how the original console works and how the emulator imitates this behaviour to the best accuracy possible, as well as comparing the resulting emulator with other existing ones.

\section{Scope}

The scope of this project is creating a new Gameboy and Gameboy Color emulator, working for browsers. Emulation will be as accurate as achievable with the time available - there may be minor inacuracies in the end product. Extra peripherals and features of the console may be omitted, to allow more focus to be put on the core part of the console.

The emulator will be usable across a range of devices. Debugging tools and additional features may be provided to the user to let them customise their experience to their needs.

\section{Objectives}

The resulting software will allow users to open a game file for the gameboy - also called a ROM - and play it. They may use the emulator on a computer, controlling the console via the keyboard, or on a touch device, using on-screen buttons. The emulated features of the emulator include proper rendering of the screen, simulating the audio of the console, the different buttons, and support for a variety of chip controllers for game cartridges.

The frontend of the emulator may also contain additional quality of life features, such as custom themes, save states, and debugging options allowing to inspect the state of the Gameboy - a feature vital to emulator developers and retro game developers.

\chapter{Background}

\section{Emulation}

An emulator is ``hardware or software that permits programs written for one computer to be run on another computer'' \cite{emulator_def}. The imitated computer is the \textit{guest}, and the one that imitates is the \textit{host}. Emulators are nowadays mainly found in the form of software, and have many different uses, from preservation to hardware development.

Emulation was technically born with the first computers: the very first computer, the Colossus made in 1941, was built to imitate the Enigma machine \cite{emulator_origin}. However emulation was properly studied towards the end of the twentieth century, when computing power started to steadily increase. One of the earliest instances of emulation as an actual feature is with the IBM System/360. This computer supported emulation of previous models, such as the IBM 709, 7090, 7094 and 7094 IIx \cite{ibm_emulation}.

Emulation is also vital for preservation: as transistors and motherboards age, old systems become unusable, and with them the software they ran. Emulating these systems is often the only future-proof and sustainable way to keep this software usable.

Finally, another common use for emulation is virtual machines. These programs allow running another \gls{os} on a computer, which can be used for instance when developing for other systems, without needing to use the physical device directly, for instance when developing a Windows-compatible app with a Linux computer.

\section{Video Game Emulation}

Video game emulation is the art of emulation applied to video game hardware systems. This allows the host to run games destined for the original console. This usually requires precise understanding of the console's hardware and functioning, as games may rely on specific behaviours and edge cases to function. This task is rendered harder by the fact that often game consoles are poorly documented, as they are proprietary hardware and programmer guides written for them cannot be legally distributed.

Video game emulation started in the 90s when computers were powerful enough to properly simulate console systems. Although precise dates are hard to get, the first console emulators seem to be either from 1990 or 1993 \cite{first_nes_emu}, and were able to run some NES games. The first Gameboy emulators were in the late 90s, with the Virtual GameBoy\ftnt{http://fms.komkon.org/VGB/} in 1995 and NO\$GMB\ftnt{https://problemkaputt.de/gmb.htm} in 1997 (although it's history page\ftnt{https://problemkaputt.de/gmbhist.htm} seems to indicate development started in 1993) \cite{first_gb_emus}.

The original game files and assembled code for video games is copyrighted material, and is referred to as the \gls{rom} of the game. Although distributing these \glspl{rom} is usually illegal, there also exist copyright free \glspl{rom}: games created by developers that chose to license them under Creative Commons licenses, for instance. Websites such as Retro Veteran\ftnt{https://www.retroveteran.com/category/nintendo-game-boy-color/} host wide collections of legal \glspl{rom}.

\section{Gameboy, Gameboy Color}

The \gls{gb} is an 8-bit handheld video game console, released in 1989. It has a small $160 \times 144$ pixel screen, and has a Sharp LR35902 as its \gls{cpu}, clocked at 4.19MHz \cite[Specifications]{pandoc}. In 1998, the \gls{gbc} was then released. Seen as the successor of the \gls{gb}, it contains a screen of the same resolution, but supporting colour, from a palette of 32768 options (15 bits per color). It contains the same \gls{cpu} as its predecessor, a Sharp LR35902, with now two modes: a 4.19MHz mode and a 8.38MHz mode (double-speed mode). This allows the \gls{gbc} to be backwards compatible with most \gls{gb} games - there are a few exceptions to this, games that used hardware bugs of the original \gls{gb} that were fixed in the \gls{gbc}.

From an emulation perspective, the \glsdesc{gbc} can thus be seen as an extension of the Game Boy - it has an identical CPU (although with a toggle-able double speed mode), and most of the memory layout is identical. To keep the remaining of this document simple, if not stated, ``GB'' will refer to both the original \glsdesc{gb} and the \glsdesc{gbc}, as they are very similar. \gls{dmg} refers to the original \glsdesc{gb} model.

\section{Existing Literature}

\subsection{Gameboy Documentation}

The \glsdesc{gb} is one of the best documented consoles for emulation, and an array of resources exist to get started writing a new one. Some useful resources explaining it's behaviour are:

\begin{compactitem}
    \item Pandocs\ftnt{https://gbdev.io/pandocs/} is a technical reference of how the \gls{gb} works. It is extremely complete and covers a wide range of topics, so it is useful to get a global view of a problem. It is one of the most referenced pieces of literature on the console.
    \item GB CPU Instructions\ftnt{https://meganesu.github.io/generate-gb-opcodes/} is a table containing all instructions the \gls{gb} \gls{cpu} has, as well as information on the amount of cycles taken by the instruction, the bytes of memory used, the flags affected by the operation, and a description of the instruction.
    \item Gameboy Complete Technical Reference\ftnt{https://gekkio.fi/files/gb-docs/gbctr.pdf} (GBCTR) is an unfinished document that contains very detailed information on the \gls{cpu} and other components of the \gls{gb}. Although incomplete, it provides a much lower-level view of the details of the \gls{gb} (compared to Pandocs), making it useful to emulate very specific behaviour like the cycle-by-cycle timing of the CPU.
    \item GB dev wiki\ftnt{https://gbdev.gg8.se/wiki/} is a wiki containing additional information on the \gls{gb}, including guides to making games and explanations on some hardware quirks, and in particular a very precise description of the \gls{apu}.
\end{compactitem}

\subsection{Existing Emulators}

A wide range of emulators for the \gls{gb} and \gls{gbc} already exist, many of them being open-source. These are useful when developing a new emulator, to see how they work internally. For performance reasons they're usually written in compiled languages, such as C++ and Rust, but some interpreted language alternatives exist. These emulators include:

\begin{compactitem}
    \item Game Boy Crust\ftnt{https://github.com/mattbruv/Gameboy-Crust} is a simple \gls{gb} emulator written in Rust. It is quite incomplete but has a comprehensive structure, so it's a good project to first figure out how emulators work.
    \item AccurateBoy\ftnt{https://github.com/Atem2069/accurateboy} is a highly accurate emulator, in particular for its \gls{ppu} that has pixel-perfect accuracy.
    \item oxideboy\ftnt{https://github.com/samcday/oxideboy} is another \gls{gb} emulator written in Rust, that is much more complete and helpful for some edge cases.
    \item SameBoy\ftnt{https://github.com/LIJI32/SameBoy} is one of the most accurate open source \gls{gb} and \gls{gbc} emulators, written in C. It is much more technically complex but still useful to understand edge cases, especially since it is the emulator I use and compare mine with.
    \item Mooneye GB\ftnt{https://github.com/Gekkio/mooneye-gb} is a \gls{gb} research emulator written in Rust. It passes most of the Mooneye test ROMs, making it helpful when encountering issues with these tests.
    \item GameBoy-Online\ftnt{https://github.com/taisel/GameBoy-Online/} is a high-accuracy JavaScript emulator, that I used when unsure on how to interface the emulator with the browser (notably for the \gls{apu}).
    \item Gameboy.js\ftnt{https://github.com/juchi/gameboy.js/} is another JavaScript emulator. It is fairly simply and inaccurate, but is easily hackable. As such it's the emulator I used when starting the emulator, to compare mine with.
    \item rboy\ftnt{https://github.com/mvdnes/rboy} is an emulator written in Rust, that I used when developing the \gls{apu} to compare mine with, as it passes some test \glspl{rom} I struggled with.
\end{compactitem}

\subsection{Gameboy Test ROMs}
\label{sec:gb-test-roms}

A core set of resources to develop an emulator is the test \glspl{rom} for that console. These are valid source code for the console, that instead of playing a game will run a set of tests on the console. These tests are first written to pass on the physical console itself, and are then used to ensure they also pass on the emulator. This means issues in specific components can be easily diagnosed (so long as the rest of the emulator responsible for running the test \gls{rom} works itself). These test \glspl{rom} also have the advantage of being open source, meaning their source code can be referred to, to understand what they expect of the console.

An other advantage to using test \gls{rom} is that they tend to re-use the same framework across a given test suite to report results. This means the result of the test is usually logged somewhere in the console, and testing can easily be automated by inspecting specific registers/memory addresses, rather than having to store an ``expect result'' image for each test.

The test \glspl{rom} used for this project are:

\begin{compactitem}
    \item Blaarg test \glspl{rom}\ftnt{https://github.com/retrio/gb-test-roms/} are some of the most well-known and used \gls{gb} test \glspl{rom}. They include tests for the \gls{cpu}, the timings of instructions, and some other functionality.
    \item Mooneye test \glspl{rom}\ftnt{https://github.com/Gekkio/mooneye-test-suite} is a very complete test suite, that verifies most components of the \gls{gb}: \gls{cpu} instructions, memory timings of specific instructions, behaviour of \glspl{mbc}, timing of the \gls{oam} \gls{dma}, \gls{ppu} timings, timer timings, etc.
    \item Acid Test (\gls{dmg}\ftnt{https://github.com/mattcurrie/dmg-acid2}, \gls{gbc}\ftnt{https://github.com/mattcurrie/cgb-acid2}) is a test that verifies the \gls{ppu} of the \gls{gb} displays data properly (to line-rendering accuracy), for both \glsdesc{gb} and \glsdesc{gbc} displays.
    \item SameSuite\ftnt{https://github.com/LIJI32/SameSuite/} is a test suite that is valuable for its \gls{apu} tests: it uses the PCM12 and PCM34 registers exclusive to the \gls{gbc} to inspect the exact ouput of the \gls{apu} (whereas other test \glspl{rom} tend to inspect the on/off status of the channels, which is much less accurate).
\end{compactitem}

\chapter{Requirements and Specification}

\section{Requirements}

\subsection{User Requirements}

\begin{enumerate}[start=1,label=U\arabic*.]
    \item Run \glsdesc{gb} games to a satisfiable fidelity, with proper rendering and controls emulation.
    \item Run \glsdesc{gbc} games to a satisfiable fidelity, with proper rendering and controls emulation.
    \item Allow the user to run \gls{gb} and \gls{gbc} games for both a \glsdesc{gb} and a \glsdesc{gbc} (ie. allow using a \gls{gbc} for a \texttt{.gbc} file, and a \gls{gb} for a \texttt{.gb} file).
    \item Allow the user to save the state of the game, to continue their playthrough later. The state can simply be saved as a downloaded file, and re-uploaded later to continue the game.
    \item Allow the user to change the speed at which the game is played: double speed mode, half speed mode, etc.
    \item Have some debug functionality, to inspect the state of the console at any given time.
    \item Allow users to pause the console, and add breakpoints to stop execution at specific moments.
    \item Allow the user to switch between rendering modes (nearest-neighbour, LCD display, scale2, etc.)
    \item Allow the user to switch the colour palette of the \gls{dmg} emulation.
\end{enumerate}

\subsection{System Requirements}

\begin{enumerate}[start=1,label=F\arabic*.]
    \item The system can receive a \gls{rom} file, construct an instance of the emulated console, and run the code inside said \gls{rom}.
    \item The system emulates different components of the \gls{gb} and \gls{gbc}, with as much precision as possible (\gls{mcyc} precision).
    \item The system renders the output of the emulator to a Web \texttt{<canvas />}.
    \item The system creates the required DOM elements for the web-app, and updates them as needed.
    \item The system listens to key presses and releases to emulate controls through the keyboard.
    \item For touch devices, the system may render buttons to simulate the console's controls.
\end{enumerate}

\subsection{Non-Functional Requirements}

\begin{enumerate}[start=1,label=N\arabic*.]
    \item The emulator should be accessible on computers through a web browser equipped with a recent version of JavaScript.
    \item The emulator should be accessible on mobile devices through a web browser equipped with a recent version of JavaScript.
    \item The emulator should be accessible on computers through a standalone app.
    \item Maximise the tests passed by the emulator (see \nameref{sec:gb-test-roms})
    \item Have the code be well documented, allowing new-comers to the project and to \gls{gb} emulation to easily understand what is going on - if possible with links to relevant \glsdesc{gb} emulation resources.
\end{enumerate}


\section{Specification}


\begin{xltabular}{\textwidth}{|c|X|c|}
    \hline
    \textbf{Code} & \textbf{Specification} & \textbf{Importance}\\
    \hline\hline
    \endhead

    U1 & User can upload a \gls{gb} \gls{rom} file (\texttt{.gb}), and the emulator will run the game. The keyboard can be used to control the game, and the output is displayed. & High \\ \hline
    U2 & User can upload a \gls{gbc} \gls{rom} file (\texttt{.gbc}), and the emulator will run the game. The keyboard can be used to control the game, and the output is displayed. & Medium \\ \hline
    U3 & User can upload a \gls{gb} \gls{rom} file (\texttt{.gb}). The user can switch between a \gls{dmg} and a \gls{gbc} emulator. & Medium \\ \hline
    U4 & User can press a button to download a save of their game (or, alternatively, the save can be stored inside the browser with a technology like IndexedDB\ftnt{https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API}) & Low \\ \hline
    U5 & User can select the speed of emulation, to dynamically accelerate/decelerate the game. & Medium \\ \hline
    U6 & User can see debug information of the emulator. This information includes the current tileset, background map, time to draw a frame, and register information. & Low \\ \hline
    U7 & User can pause the console emulation through a button. They can also input conditions for which the console should break execution. & Low \\ \hline
    U8 & User can dynamically switch the rendering filter via a dropdown button. & Low \\ \hline
    U9 & User can dynamically switch the colour palette of the GameBoy via a dropdown button. & Low \\ \hline

    F1 & A \gls{rom} file can be uploaded, is transformed into an \texttt{UInt8Array} (because the \gls{gb} is an 8-bit system), and the appropriate object is created to run the code. & High \\ \hline
    F2 & Different components exists as different classes, respecting typical OOP principles such as encapsulation and inheritance when relevant. & High \\ \hline
    F3 & A \texttt{<canvas />} element is created, and is updated with the output of the emulator after every frame is drawn (ie. at the start of each VBlank mode). & High \\ \hline
    F4 & The Preact\ftnt{https://preactjs.com/} framework is used to handle the UI of the web-app. & High \\ \hline
    F5 & Listeners are added to the environment's \texttt{window} to listen to all key presses and releases. The emulator can then request for a control update, by reading the state of keys. & High \\ \hline
    F6 & If a touch device is detected, button are added to the UI and are used by the emulator as inputs. & Medium \\ \hline

    N1 & A deployed version of the web-app is accessible on a desktop browser and provides full functionality, via keyboard and mouse inputs. & High \\ \hline
    N2 & A deployed version of the web-app is accessible on a mobile device browser and provides full functionality, via touch controls. & Medium \\ \hline
    N3 & A downloadable version of the web-app can be used on a computer and provides full functionality, via keyboard and mouse inputs. & Low \\ \hline
    N4 & As many possible tests as possible should be passed, while ensuring previously passing tests don't start failing. & Medium \\ \hline
    N5 & Main methods and variables must be properly documented, and have links to appropriate online resources to documentation about said element. & High \\ \hline
\end{xltabular}

\chapter{Design}

In this chapter we will outline the main components of the Gameboy and of this emulator. For the different \gls{gb} components, we will briefly go over their role, and how they interact with other components and to what end.

In emulators, the different components are usually split in three parts:
\begin{compactitem}
	\item The \gls{cpu}, responsible for reading instructions and changing the state of the console. This is what drives the emulation, as other components usually idle unless acted upon.
	\item Input and output components, such as the \gls{apu}, the \gls{ppu} and the joypad. These components interact with the outside user, by either outputing the game state, or reading inputs from the user.
	\item A memory system, that handles addressing within the console. This part is essential to ensure components are communicating between each other properly, since different addresses may map to different components.
\end{compactitem}

Because the emulator should not rely on the environment it is running it to work, the functionality of the project can be split into two parts: the emulator core, that is responsible for simulating the Gameboy, and the emulator's frontend, that allows interfacing with the user, and may be changed to work for different platforms (see \ref{fig:emu-back-front-split-uml}).

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
    	\umlbasiccomponent[x=4]{EmulatorUI}
    	\umlbasiccomponent[y=3]{Gameboy}
    	\umlHVassemblyconnector[interface=EmulatorOut, with port]{EmulatorUI}{Gameboy}
    	\umlHVassemblyconnector[interface=EmulatorIn, with port]{Gameboy}{EmulatorUI}
    \end{tikzpicture}
    \caption{Split of emulator core and frontend}
    \label{fig:emu-back-front-split-uml}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics{diagrams/emulator-comp-diagram.drawio.pdf}
    \caption{Simplified design of the emulator's core}
    \label{fig:emu-core-components}
\end{figure}


\section{Emulator Frontend}

To allow the user to access the emulator, a frontend needs to be built with it. This frontend is responsible for outputting the graphics and audio data of the emulator, and also for receiving input from the user to pass down to the emulator. Aside from that, extra UI components have been added, to make the usage of the emulator more convenient and add more features: a play/pause button, custom themes, debugging tools, upscaling filters and keybinding options. All of these are kept independent from the emulator, and control transformations of the input/output, or changes in the running of the emulator.

Because this implementation is merely to allow access to the emulator and doesn't have any outstanding functionality, it's description will be brief - most of the focus will be put on the emulator's core.

\section{CPU}

The \glsfirst{cpu} is perhaps the most complex part of the \gls{gb}. It is however also one of best documented parts of it, making it quite easy to emulate properly. The \gls{cpu} model is a LR35902, which is a hybrid of the Intel 8080 chip and the Zilog Z80 \cite{gbcpumanual}.

Most emulator are typically ``CPU-driven''. This means that the \gls{cpu} is what drives the emulation. If an instruction takes multiple hardware cycles to execute, the \gls{cpu} is responsible for asking the rest of the system to tick at the appropriate time. In the design chosen for this project however, the emulator will be ``System-driven'', with the \gls{cpu} only being part of the overall running of the emulator, and will not be responsible for ticking the rest of the system. This difference will be made obvious by the interfaces exposed to the \gls{cpu}; it allows for nicer encapsulation and better separation of concerns.

The \gls{cpu} is thus responsible for stepping through the program it's given. It has 6 different 16-bit registers, with different roles. Some registers' bytes can be accessed independently, operating as two 8-bit registers or one 16-bit register as needed \cite[CPU Registers and Flags]{pandoc}.

\begin{compactitem}
	\item \texttt{AF}: the accumulator-flag register. Most arithmetic operations can be done on \texttt{A}. \texttt{F} holds the \gls{cpu}'s flags, and can only be altered through arithmetic opeartions.
	\item \texttt{PC}: the program counter register. It cannot be accessed directly, and is used to store the current position of the \gls{cpu} in the program. It can be altered via \texttt{CALL}, \texttt{RET}, \texttt{JP} operations, for instance.
	\item \texttt{SP}: the stack pointer register. It can be modified or incremented, and stores the pointer to the top of the ``stack''. A typical use of the stack is for handling functions, by pushing the current address to the stack whenever a procedure is called, and popping it back to the stack pointer when it returns.
	\item \texttt{BC}, \texttt{DE}: two simple registers that can be used for arithmetic operations.
	\item \texttt{HL}: similar to \texttt{BC} and \texttt{DE}, it can also be used as an address by some operations - allowing the use of indirect addressing.
\end{compactitem}

Aside from it's registers, the \gls{cpu} needs to interact with system interrupts, and needs to access memory for reading/writing operations.

% TODO: Keep this for implementation?
%
% Each opcode (operation code) of the \gls{gb} is one byte long, meaning there could be $2^8=256$ different opcodes. However, there exist 16-bit opcodes, to allow the \gls{cpu} to perform more operations. These 16-bit opcodes always start with \texttt{0xCB}, with the second byte containing what operation is executed. There are also 11 values of the opcode that do nothing, and aren't used in any \glspl{rom}. This brings the total number of operations to $2^8 * 2 - 11 = 501$.

\section{PPU, APU, Joypad}

The \glsfirst{ppu} is a complex part of the Gameboy, that handles outputting the game state to a $160 \times 144$ screen, that may either be monochrome on the \gls{dmg} or with color support on the \gls{gbc}. It may raise interrupts, and needs to be able to access memory, due to it being responsible for the \glsfirst{oam} - a feature allowing transfer of data from an arbitrary location in memory.

The \glsfirst{apu} is responsible for playing the audio output of the console. It has a few registers to control it, as well as a short memory area called the wave RAM. It is partially controlled by the timer, but is otherwise independent. It's sound output is derived from four separate channels: two square wave channels, a custom wave chanel, and a noise channel \cite[Audio]{pandoc}. These channels are here modelled as separate entities, but are purely internal.

The former two components need to output information to the user, either graphic or audio data. To do this in a portable way, the emulator will expose an interface, that can be implemented by the front-end. This allows the emulator core to be platform-agnostic, and be easily portable.

The joypad, on the other hand, is the one input component the \gls{gb} has. It contains 4 directional arrow buttons, and 4 input buttons: A, B, start and select (see \ref{fig:gb-front}). To use these inputs, the \gls{cpu} needs to use two different registers.

Similarly as for the output, the emulator core will expose an interface to read  the user's input, ie. the state of all 8 buttons.

\begin{figure}[h]
    \centering
    \includegraphics[width=4cm]{images/gameboy}\\
    \caption{Picture of a Gameboy, with the screen and joypad visible}
    \label{fig:gb-front}
\end{figure}

\section{System Bus}

Components withing the Gameboy need to communicate. To do this, components typically have a set of registers that control how they behave - for instance, the timer has a \texttt{TAC} register at \texttt{0xFF07} to control it's frequency. To allow this interaction without having all components directly depend on each other, a ``system bus'' component is created, responsible for handling all components and managing memory-addressing among them.

This component, called \texttt{System}, is thus responsible for instantiating the other components, and providing them access to eachother, via a read and write method.

\section{Other Components}

Aside from the aforementioned components, the \gls{gb} has a few components that allow it to run but aren't part of the \gls{cpu} or the input/output components. These will be briefly outlined here, as they have a lesser impact on the emulator's design.

\subsection{Timer}

The timer, responsible for incrementing a counter (the \texttt{DIV}) at a set frequency. It can raise interrupts, and owns a few registers.

\subsection{Interrupts}

The interrupt system, that allows components such as the timer or the \gls{ppu} to interrupt the \gls{cpu} to run another process. It can also be enabled and disabled by the \gls{cpu}, with the \texttt{EI} and \texttt{DI} instructions.

This sub-system is designed as a separate component to reduce coupling between other components, and instead have a small object that can be passed to components as needed.

\subsection{MBC}

The \glsfirst{mbc} is an extra chip contained within some game cartridges, to allow access to more \gls{rom} data (as well as external RAM in some cases) via banking \cite[MBCs]{pandoc}. There are multiple different \glspl{mbc}, and so it is convenient to define a common interface for all of them, which can then be implemented according to specification for each \gls{mbc} type.

The type of the \gls{mbc} is in the header of the \gls{rom} \cite[The Cartridge Header]{pandoc}. To separate this logic from the base system, a \texttt{ROM} class is used. It is responsible for reading the cartidge's header, and creating the appropriate \gls{mbc} instance.

\section{Useful Classes}

To have similar interfaces over all components, we will also declare specific classes and interfaces to be implemented by them.

\subsection{Addressable}

The \texttt{Addressable} interface provides a read and write method. This allows all components to communicate between each other without needing to be aware of what the component they're communicating with is. Aside from the \gls{cpu}, all components of the emulator implement this method.

\subsection{Memory and registers}

Simple utility classes can be declared to manage memory in a simple way.

The \texttt{RAM} class implements \texttt{Addressable}. It can be instantiated with a set size, and can be read and written to. It is used in components that have large blocks of writable data.

The \texttt{Register} class implements \texttt{Addressable}, but ignores the address parameter of the read and write operations, as it contains only one byte. A \texttt{DoubleRegister} class may also be implemented, backed by two \texttt{Register}s, to provide support for 16-bit registers, used for instance in the \gls{cpu}.

\chapter{Implementation}

The project uses Preact\ftnt{https://preactjs.com/}, a light-weight alternative to the more popular React\ftnt{https://reactjs.org/} framework. Preact was chosen because the front-end of the web-app is extremely lightweight, so a smaller framework with less features is enough. This also avoids bloating the app with a heavy framework such as React: its GZipped and minified size is around 31.8Kb, while Preact is only 4Kb (87\% less).

The language used for the project is TypeScript\ftnt{https://www.typescriptlang.org/}, a typed version of JavaScript. This is essential for the project, as ensuring the correctness of code can be extremely hard without proper typing constraints, especially as a project grows in size.

The project is divided into two parts:
\begin{compactitem}
    \item The \texttt{frontend/} directory contains the UI for the web-app. The main logic to create the emulator and run it is contained in \texttt{app.tsx}.
    \item  The \texttt{emulator/} directory contains the actual \gls{gb} emulator. Although most classes and interfaces used are exported, only three elements are needed to properly interact with the emulator:
    \begin{compactitem}
        \item \texttt{GameBoyColor.ts} handles the core loop of the system. It contains the \texttt{GameBoyColor} class, the emulator. Instantiating the emulator creates all the necessary sub-components, and calling the \texttt{drawFrame()} method runs the emulator for one frame (0.16 seconds).
        \item \texttt{GameBoyOutput.ts} contains a simple interface, with optional methods to receive any output produced by the emulator (see figure \ref{fig:gameboyoutput}). The two main methods of this are \texttt{receiveGraphics} and \texttt{receiveSound}, which use the output of the actual console.
        \item \texttt{GameBoyInput.ts} contains a simple interface with a required \texttt{read()} method that returns an object with the current inputs for the console (see figure \ref{fig:gameboyinput}).
    \end{compactitem}
\end{compactitem}

\begin{figure}[h]
    \begin{minted}{typescript}
interface GameBoyOutput {
    receiveGraphics?(data: Uint32Array): void;
    receiveSound?(data: Float32Array): void;

    // Debugging methods:
    debugBackground?(data: Uint32Array): void;
    debugTileset?(data: Uint32Array): void;
    serialOut?(data: number): void;
}
    \end{minted}
    \caption{\texttt{GameBoyOutput} interface methods}
    \label{fig:gameboyoutput}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
type GameBoyInputRead = {
    up: boolean;
    down: boolean;
    left: boolean;
    right: boolean;

    a: boolean;
    b: boolean;
    start: boolean;
    select: boolean;
};

interface GameBoyInput {
    read(): GameBoyInputRead;
}
    \end{minted}
    \caption{\texttt{GameBoyInput} interface method}
    \label{fig:gameboyinput}
\end{figure}

\section{Emulator Frontend}

The frontend of the emulator is written in Preact, allowing us to create a simple, fast and lightweight UI to control it. It contains the emulator title, the control buttons and the emulator video output (see figure~\ref{fig:emmy-home}). Along the left of the screen is a sidebar with more options, allowing the user to customise the emulator to their needs and debug the state of the console if needed.

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/emmy-home-page}\\
    \caption{Home page of the emulator}
    \label{fig:emmy-home}
\end{figure}

\subsection{Main Controls}

The main controls for the emulator are the 6 buttons above the screen. These are, from left to right:

\begin{compactitem}
    \item Pause/play: pauses or resumes the emulator.
    \item Step by one \gls{cpu} instruction: this is a feature useful for debugging the emulator, when precise information of the state of the emulator is needed.
    \item Sound toggle: allows enabling or disabling the sound of the emulator. By default the sound is turned off, because modern browsers don't allow websites to play any sound before the user interacts with the website \cite{browser_autoplay}.
    \item Triple speed toggle: a toggle button that speeds up the emulator to emulate the \gls{gb} thrice as fast as usual. This is a common feature found in most emulators.
    \item Save state: saves the current state of the cartridge in the browser's storage, allowing the user to resume playing the game later. Note this doesn't save the full state of the emulator, but that of the cartridge, making it equivalent to a real-life save on the \gls{gb} where only the battery-backed storage of the cartridge persists through power-offs.
\end{compactitem}

\subsection{Settings}

In the side drawer, the first tab is ``Settings''. It contains general settings for the emulator, such as:

\begin{compactitem}
	\item the console used by the emulator. This may either be the \gls{dmg} or the \gls{gbc}.
	\item an extra filter to be applied to the output. This increases the resolution of the screen, using the Scale2x or Scale4x\ftnt{https://www.scale2x.it/} algorithm (see \ref{fig:scale-filter}).
	\item the size of the emulator's screen, allowing resizing to two or four times larger.
	\item a slider to change the volume of the emulator's audio output.
	\item a palette selector, to change the four hues of the \gls{dmg}'s screen.
	\item miscellaneous togglable settings, grouped together: 
	\begin{compactitem} 
		\item an option to play with or without the initial boot \gls{rom} of the emulator.
		\item a toggle to enable frame-blending, meaning for every new frame the output is mixed with the previous frame. This is a nice addition to have, because certain games made certain objects flicker on screen to make them appear translucent (since the flicker wasn't visible to the eye).
		\item a button to show the performance statistics of the emulator. This is mainly useful when developing the emulator to make sure it is still efficient.
		\item a toggle to enable the debug view of the emulator, where the currently loaded tileset and background map are displayed (see \ref{fig:debug-view}).
	\end{compactitem}
\end{compactitem}

\begin{figure}[h]
    \centering
    \includegraphics[width=15cm]{images/scale-filter}\\
    \caption{Output of the \gls{gbc} with, from left to right: no filter, Scale2x and Scale4x}
    \label{fig:scale-filter}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{images/debug-view}\\
    \caption{Debug view of the emulator}
    \label{fig:debug-view}
\end{figure}

\subsection{Watch Expressions}

The second drawer allows the user to define custom JavaScript functions to inspect the state of the emulator regularly (see \ref{fig:watch-expressions}). This requires knowledge of the inner structure of the emulator, as the field names need to be used, but is quite useful when needing to inspect parts of the console that aren't the memory, like internal counters used for components, or register values. 

To implement this, the \texttt{Function}\ftnt{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function} constructor is used, which takes in a string with the function's code. This allows the user to dynamically change the expression, and the component will simply update the function, without needing to reload the whole application. These expressions are also automatically saved to \texttt{localStorage}\ftnt{https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}, meaning they will be kept between sessions.

The user-defined function is then repeatedly invoked, and the result output below the expression, allowing for a live-status of the emulator. If an error is thrown by the function (due to a null value, or invalid expression), the error is caught and `\texttt{Error}' is displayed.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/watch-expressions}\\
    \caption{Watch expressions drawer}
    \label{fig:watch-expressions}
\end{figure}

\subsection{Test ROMs}

To ensure emulators work properly, a variety of test \glspl{rom} have been made, that test most aspects of the \gls{gb} (see \ref{sec:gb-test-roms}). The front-end of the emulator supports running a large number of them in an automated way (see \ref{fig:}). The user can select the group of tests desired, and they will run internally (without receiving any input our outputting anything directly). The status of each individual test is displayed, and the user can click on the test name to run it on the main emulator, for further debugging or inspection.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/test-roms}\\
    \caption{Test \glspl{rom} drawer}
    \label{fig:watch-expressions}
\end{figure}

To run the tests, an emulator instance is created, with the test \gls{rom} as the input data and ``spy'' objects provided for input and output - these spies store the output of the emulator, to evaluate the state of the test. To stop execution, the emulator's state is inspected regularly, and the outcome of the test is checked (with execution terminating if the test takes too long to end).

To detect the outcome of each test, these are grouped according to what test suite they belong to. Each test suite is then associated to a \textit{success function}, that can either return \texttt{"success"}, \texttt{"failure"} or \texttt{null} if no outcome has been reached yet. As such, all tests in a test suite have a similar way of reporting success and failure.

The currently automated test suites are:
\begin{compactitem}
	\item The Blaarg test \glspl{rom}\ftnt{https://github.com/retrio/gb-test-roms}. The success function of this suite is quite complex, as this suite doesn't have a standard way of outputting the result. As such multiple parts of the emulator are inspected simultaneously:
		\begin{compactitem}
			\item \texttt{"Passed"}\footnote{See lines 50-54 of \texttt{mem\_timing/source/common/testing.s} in \url{https://github.com/retrio/gb-test-roms}} and \texttt{"Failed"}\footnote{See lines 112-139 of \texttt{mem\_timing/source/common/runtime.s} in \url{https://github.com/retrio/gb-test-roms}} may be output to the console's serial port.
			\item If the memory at \texttt{0xa001-0xa003} is equal to \texttt{0xdeb061}, then the byte stored at \texttt{0xa000} is the status of the test\footnote{See `Output to memory' in \texttt{dmg\_sound/readme.txt} of \url{https://github.com/retrio/gb-test-roms}}.
			\item For the \texttt{halt\_bug} test, there doesn't seem to be anywhere where the result is output, so the graphical output of the emulator is verified.
		\end{compactitem}
	\item The Mooneye test \glspl{rom}\ftnt{https://github.com/Gekkio/mooneye-test-suite} and SameSuite\ftnt{https://github.com/LIJI32/SameSuite/}, of which all tests are verified the same way. In case of success, the \texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{H} and \texttt{L} registers hold the values $3$, $5$, $8$, $13$, $21$ and $34$ respectively (Fibonacci's sequence). If they instead all hold the value \texttt{0x42}, the test failed\footnote{See \url{https://github.com/Gekkio/mooneye-test-suite/\#passfail-reporting} for the Mooneye test suite, see lines 265-281 of \texttt{include/base.inc} in \url{https://github.com/LIJI32/SameSuite/} for the SameSuite}.
	\item The Acid test \glspl{rom} (\gls{dmg}\ftnt{https://github.com/mattcurrie/dmg-acid2}, \gls{gbc}\ftnt{https://github.com/mattcurrie/cgb-acid2}). These need to be tested graphically, as their purpose is verifying the actual output of the emulator rather than it's behaviour.
\end{compactitem}

Thanks to this, the emulator's frontend supports a total of 191 automated test \glspl{rom}, that verify the behaviour of most of the emulator. Of these 191 tests, 101 pass.

\subsection{Memory Inspect}

When debugging an emulator, being able to inspect it's memory is essential, as some bugs may be caused by the wrong mapping of components, or a fault when writing data. To help debugging this, the frontend comes with a basic memory inspection tool, that can show the entirety of the \textit{addressable} data of the emulator (see \ref{fig:memory-inspect}). This means data that is not accessible by the game (for instance, because the appropriate \gls{rom} bank is not selected) cannot be inspected here. A simple offset can also be indicated, to restrain the data to a certain area.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/memory-inspect}\\
    \caption{The memory inspection drawer}
    \label{fig:memory-inspect}
\end{figure}

\subsection{Keybindings}

The user can also customise their keybindings for the emulator, by mapping each input to a separate key (see \ref{fig:keybindings}). This is only relevant on keyboard-equipped devices.

\begin{figure}[h]
    \centering
    \includegraphics[width=5cm]{images/keybindings}\\
    \caption{The keybindings settings}
    \label{fig:keybindings}
\end{figure}

\section{CPU}

The \gls{cpu} is the core of the emulator, and allows running the code from the \gls{rom} by reading the operation code (or opcode) and executing the matching action.

\subsection{Instruction Set Decoding}

Because the \glsdesc{gb} is an 8-bit system, opcodes are 8 bits (or one byte) long, giving in theory a maximum of $2^8=256$ operations. However in the \gls{gb} the operation \texttt{0xCB} gives access to an extended instruction set, meaning that when reading \texttt{0xCB} the \gls{cpu} will read the next byte and use a different logic to execute the operation. This means there are now $2^8 - 1 + 2^8=511$ operations. The \gls{gb} also has 11 `unused' opcodes, that will lock the console when used\cite[CPU Comparison with Z80]{pandoc}, meaning there are in total $2^8 - 12 + 2^8 = 500$ operations to implement.

Multiple techniques exist to handle this large number of operations:

\begin{compactitem}
    \item Have a large switch-statement for all possible operations. This is the most straight-forward option, but can result in quite large switch-statements, especialy for \glspl{cpu} with more opcodes. The \gls{gb} has comparatively few opcodes as it is an 8-bit system; the Gameboy Advance, the console that followed it, had 32-bit opcodes: way too many for a switch statement to be appropriate.
    \item Decode the operation by reading specific parts of the opcode, and generate the instructions dynamically. This method is what is done for larger instruction sets, where opcodes can be split into separate parts to describe the operation's behaviour \cite[ARM CPU Reference]{gbatek}. It however comes with the cost of extra processing for each instruction, as it needs to be decoded. This method is applicable to the \gls{gb}, as many instructions follow a pattern - see, for instance the \texttt{LD} instructions, that all follow the same order of registers: \texttt{B}, \texttt{C}, \texttt{D}, \texttt{E}, \texttt{H}, \texttt{L}, \texttt{(HL)} (the byte at address \texttt{HL}) and \texttt{A}.
    \item Have a map, that associates for each opcode a function to execute. This technique is also only viable for small numbers of opcodes, as the map can result quite large. An advantage of this method is that the map doesn't have to be explicitly written out entirely - generators can be used to populate some chunks of it, making it a hybrid of the two previous solutions: there is very little overhead to execute an instruction, as each opcode is associated to a function, but there is also no need to write out every instruction separately, as the map can be generated in parts or in its entirety (inducing a light setup cost).
\end{compactitem}

Initially, the emulator had a large map, with all the opcodes as keys. The functions associated would then execute the instruction and return the number of cycles taken by the instruction (see figure \ref{fig:instset-first}). This however proved quite repetitive and prone to errors. To solve this, a \textit{generator function} was created. To use it, two parameters must be given: a map of opcodes to values (of an arbitrary type), and a helper function that for each arbitrary value returns a function that executes the instruction (see figure \ref{fig:cpu-gen-function}). This allows generating repetitive instructions more easily, by only specifying what opcodes and objects are used, and not what the whole body of the instruction is (see figure \ref{fig:instset-second}). This method is used in other emulators - for instance, Sameboy has a map that has an opcode-function mapping for all opcodes, and uses macros to generate the different functions\ftnt{https://github.com/LIJI32/SameBoy/blob/master/Core/sm83\_cpu.c}.

\begin{figure}[h]
    \begin{minted}{typescript}
protected instructionSet: Partial<Record<number, InstructionMethod>> = {
    // NOP
    0x00: () => 1,
    // LD BC/DE/HL/SP, d16
    0x01: (s) => { this.regBC.set(this.nextWord(s)); return 3; },
    0x11: (s) => { this.regDE.set(this.nextWord(s)); return 3; },
    0x21: (s) => { this.regHL.set(this.nextWord(s)); return 3; },
    0x31: (s) => { this.regSP.set(this.nextWord(s)); return 3; },
    ...
}
    \end{minted}
    \caption{Initial instruction set implementation}
    \label{fig:instset-first}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
protected generateOperation<K extends number, T>(
    items: Record<K, T>,
    execute: (r: T) => InstructionMethod
): Record<K, InstructionMethod> {
    const obj: Record<K, InstructionMethod> = {};
    for (const [opcode, item] of Object.entries(items)) {
        obj[opcode] = execute(item);
    }
    return obj;
}
    \end{minted}
    \caption{Generator function used for the CPU}
    \label{fig:cpu-gen-function}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
protected instructionSet: Partial<Record<number, InstructionObject>> = {
    // NOP
    0x00: () => 1,
    // LD BC/DE/HL/SP, d16
    ...generateOperation(
        {
            0x01: this.regBC,
            0x11: this.regDE,
            0x21: this.regHL,
            0x31: this.regSP,
        }, 
        (register) => (s) => {
            register.set(this.nextWord(s));
            return 3;
        }
    ),
    ...
}
    \end{minted}
    \caption{Improved instruction set implementation}
    \label{fig:instset-second}
\end{figure}

\subsection{A cycle accurate CPU}

The Gameboy is a memory-bound system, meaning that it is limited by it's memory accesses. The \gls{cpu} can only execute either one read or one write per \gls{mcyc} \cite[CPU core timing]{gbctr}. The \gls{cpu} also needs to retrieve the opcode for each instruction, which takes an additional cycle, meaning an instruction performing no memory accesses lasts one cycle, and an instruction performing $n$ memory accesses lasts at least $n + 1$ cycles. Note also that the \gls{gb} overlaps the last cycle of the execution with the fetching cycle for the next opcode - this will thus be of importance when implementing the fetching of the opcode.

\begin{figure}[h]
	\begin{center}	
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{LD rr, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
    \end{center}
    \caption{Timing of the \texttt{LD rr, nn} instruction (taken from GBCTR \cite[Sharp SM83 instruction set]{gbctr})}
    \label{fig:ld-instr-timing}
\end{figure}


The current implementation is not \gls{mcyc} accurate: the \gls{cpu} instruction is executed as one monolithic block, rather than in different smaller parts. This becomes crucial when the timer, \gls{oam} and \gls{ppu} are involved, as they run in parallel with the \gls{cpu}, so memory accesses to these components may return different values depending on the \gls{mcyc}.

In all emulators that were found when researching for this project, \gls{mcyc} accuracy is reached by making the emulator ``\gls{cpu}-driven''. What this means is that inside each instruction, between each cycle, the \gls{cpu} is responsible for ticking the rest of the system - the main loop is then only responsible for continuously running the \gls{cpu}, and nothing else. This approach is probably the simplest and most straightforward one, as it is quite simple to implement - all one needs to do is call the system tick method when relevant (see figure \ref{fig:cpu-driven-ld}).

Some emulator where this method was found:
\begin{compactitem}
	\item In Mooneye GB, this can be seen by the usage of the \texttt{CPUContext.tick\_cycle()} method when appropriate\footnote{See \url{https://github.com/Gekkio/mooneye-gb/blob/master/core/src/cpu.rs}}.
	\item In accurateboy, the \texttt{Bus.tick()} method is called from within the instructions (or it is done implicitly by methods such as \texttt{Bus.read()})\footnote{See \url{https://github.com/Atem2069/accurateboy/blob/master/accurateboy/CPU.cpp}}.
	\item In Sameboy, the \gls{cpu} uses functions like \texttt{cycle\_read} or \texttt{cycle\_no\_access} to tick the rest of the system\footnote{See \url{https://github.com/LIJI32/SameBoy/blob/master/Core/sm83\_cpu.c}}.
\end{compactitem}


\begin{figure}[h]
    \begin{minted}{typescript}
protected ld_bc_hl(system: System) { // LD BC, (HL)
    const lower = system.read(this.regPC.inc());
    system.tick();
    const upper = system.read(this.regPC.inc());
    system.tick();
    this.regBC.set(upper << 8 | lower);
}
    \end{minted}
    \caption{CPU-driven \texttt{LD BC, (HL)}}
    \label{fig:cpu-driven-ld}
\end{figure}

This solution however comes with the cost of coupling the \gls{cpu} to the system, or at least to a way of ticking said system. A particularity of this emulator is that the \gls{cpu} is almost autonomous, in that it doesn't interact with any other functionality of the system, except the interrupts. The only other interface it requires being an \texttt{Addressable}, to allow access to memory. This also means the emulator is no longer ``\gls{cpu}-driven'', since the \gls{cpu} \textit{cannot} tick the rest of the system. It is instead up to the root system to tick all of the components (including the \gls{cpu}). This is thus a code quality improvement, that isn't present in other emulators.

This was done by splitting all the instructions into their respective steps, and have each step return the next step (or \texttt{null} if it's the last step). The \gls{cpu} now must simply store whatever the instruction returns: if it's \texttt{null} then it needs to fetch an instruction to prepare for the next cycle, otherwise it's a function and must be executed (and it's result stored for the next step). See figures \ref{fig:system-driven-ld} and \ref{fig:system-driven-cpu-tick} for an example of this.

In the final version of the \gls{cpu}'s tick method, a method \texttt{loadNextOp} is implemented. It not only handles getting an instruction associated with the desired opcode, but it also is responsible for checking if an interrupt was raised (in which case the interrupt handling procedure occurs \cite[Interrupts]{pandoc}), and for ensuring the \gls{cpu} isn't halted before running an instruction.

\begin{figure}[h]
    \begin{minted}{typescript}
protected ld_bc_hl(system: Addressable) { // LD BC, d16
    const lower = system.read(this.regPC.inc());
    return () => {
        const upper = system.read(this.regPC.inc());
        return () => {
            this.regBC.set(upper << 8 | lower);
            return null;
        }
    }
}
    \end{minted}
    \caption{System-driven \texttt{LD BC, d16}}
    \label{fig:system-driven-ld}
\end{figure}

\begin{figure}[h]
    \begin{minted}{typescript}
step(system: Addressable, interrupts: Interrupts) {
    if (this.nextStep === null) {
        // looks up opcode in instruction table
        const nextStep = this.loadNextOp(system, interrupts, verbose);
        if (nextStep === "halted") return true;
        this.nextStep = nextStep;
    }
    this.nextStep = this.nextStep(system, interrupts);
    if (this.nextStep === null) {
        // opcode is fetched on the last cycle of execution
        this.currentOpcode = system.read(this.regPC.inc());
    }
}
    \end{minted}
    \caption{System-driven step of the \gls{cpu}. Note how the opcode is fetched directly when the next instruction is over, to emulate the overlap between the fetch and the execute steps.}
    \label{fig:system-driven-cpu-tick}
\end{figure}


\section{System}

The \texttt{System} class implements the system bus, as well as the ticking of all other components. It handles the ticking of the \gls{ppu}, timer, \gls{apu} and interrupt logic. Furthermore, it is the component that links all of the data together: whenever a component is ticked (any of the above or the \gls{cpu}), the \texttt{System} instance is passed, so that the components can read and write to the rest of the system. It implements \texttt{Addressable} (see \ref{fig:addressable}), and internally has a \texttt{getAdress} method that returns the \texttt{Addressable} at this specific address, to be accessed in the \texttt{read} and \texttt{write} methods. This ensures that the logic used to determine what component is accessed depending on the address isn't duplicated.

\subsection{\texttt{getAddress} optimisation}

Because \texttt{System} is a higly used component and is accessed for almost every read and write, the \texttt{getAddress} method is under a lot of pressure: for a game like `The Legend of Zelda: Link's Awakening DX', the method is called around 650,000 times per second. For a more complex and resource-intensive game such as `Alone in the Dark: The New Nightmare', around 1,900,000 calls are made. This intensity in usage can easily be explained, as the \gls{gb} is a memory-bound system: almost all interactions between components occur through memory reads and write. \texttt{getAddress} must thus be optimised as much as possible, as it is one of the main bottle-necks of the emulator.

An initial implementation of \texttt{getAddress} used the combination of a list of if-statements for different ranges of the \gls{mmap}, as well as a map where all register addresses where mapped to the component responsible for them. The code would first check if the key exists in this map,,and if not it would then go through a series of if-conditions  (see figure \ref{fig:getaddress-before}). It would not return a tuple, containing both \texttt{Addressable} to use and the address within in - this was needed as some components had a particular mapping to memory. This is the case for the \gls{wram}, who's memory starts at \texttt{0xC000} and ends at \texttt{0xFDFF} (spanning over 15.5KB bytes) despite it only being 8KB long, because the last 7.5KB of its address range map back to the beginning of it (this is called the Echo RAM \cite{memorymap}).

\begin{figure}[h]
    \begin{minted}{typescript}
protected getAddress(pos: number): AddressData {
    const register = {
        0xff00: this.joypad,
        ...
        0xffff: this.intEnable,
    }[pos];
    if (register !== undefined) return [register, pos];

    if (0x0000 <= pos && pos <= 0x7fff) return [this.rom, pos]; // ROM Bank
    ...
    if (0xfe00 <= pos && pos <= 0xfe9f) return [this.oam, pos]; // OAM

    // Unmapped area, return 'fake' register
    return [{ read: () => 0xff, write: () => {} }, 0];
}
    \end{minted}
    \caption{Initial implementation of \texttt{getAddress}}
    \label{fig:getaddress-before}
\end{figure}

This proved quite costly:
\begin{compactitem}
    \item This code creates a new map every time it is called, when checking for the registers' addresses.
    \item Having to return both an \texttt{Addressable} and an address is quite costly, as a new array with two items must be created every time. It also adds unecessary complexity to the method, as the system bus shouldn't be responsible for handling the details of address mapping, and instead simply delegate the task to the appropriate component.
    \item The if-conditions for the ranges of the biggest areas of memory (everything between \texttt{0x0000} and \texttt{0xEFFF}) happened after the register checks, which delayed response for these reads and writes. This is all the more important that this range represents $\frac{\texttt{0xEFFF}}{\texttt{0xFFFF}+1} \approx 93\%$ of the total address space.
    \item Chaining if-conditions is unneficient, as the JS engine must step through all conditions and check the values each time. Furthermore, although having both the lower and upper bound of the memory section indicated in the condition (e.g. \texttt{0x0000 <= pos \&\& pos <= 0x7FFF} for $[\texttt{0x0000}; \texttt{0x7FFF}]$) makes the translation from \gls{mmap} to code easier, it is slower, since only the upper bound of the range is needed for the condition if all the ranges below have already returned.
\end{compactitem}

First, we may move the fine-grained addressing logic to sub-components like the \gls{wram}. This removes the need to return an address from the method: only an \texttt{Addressable} is enough, as that component will then be responsible for decoding the address further. 

The last two points may then be addressed, by removing the use of if-conditions, and moving this part of the code to the beginning of the function.

With the memory map of the console (see figure \ref{fig:memory-map-largest}) we can notice how the largest chunks of memory all end with the last three nibbles of the address as \texttt{0xFFF}. This means that the component mapped to an address can be determined by simply looking at the first nibble of said address. This is probably done to simplify the circuitry responsible for addressing, as only the most significant 4 bits need to be compared. The emulator can take advantage of this.

\begin{figure}[h]
    \centering
    \caption{Memory map for the largest chunks of memory \cite{memorymap}}
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Start} & \textbf{End} & \textbf{Description} \\ \hline
    \texttt{0000} & \texttt{3FFF} & 16 KB ROM bank 00 \\ \hline
    \texttt{4000} & \texttt{7FFF} & 16 KB ROM Bank 01$\sim$NN \\ \hline
    \texttt{8000} & \texttt{9FFF} & 8 KB Video RAM (VRAM) \\ \hline
    \texttt{A000} & \texttt{BFFF} & 8 KB External RAM \\ \hline
    \texttt{C000} & \texttt{CFFF} & 4 KB Work RAM (WRAM) \\ \hline
    \texttt{D000} & \texttt{DFFF} & 4 KB Work RAM (WRAM) \\ \hline
    \texttt{E000} & \texttt{FDFF} & Mirror of \texttt{0xC000}$\sim$\texttt{0xDDFF} \\ \hline
    \end{tabular}
\end{figure}

For this area of memory (\texttt{0x000}-\texttt{0xEFFF}) the system bus may simply isolate the most significant nibble, and then use a map to associate each address block to a component. Only if the address corresponds to \texttt{0xF-{}-{}-} do we try matching it to a register address. This removes the need for the if-conditions, and is also faster as it is evaluated much earlier on (see figure \ref{fig:getaddress-after}). The map can be created on instantiation and kept for later use, to avoid unnecessary memory allocations.

\begin{figure}[h]
    \begin{minted}{typescript}
protected getAddress(pos: number): Addressable {
    // Checking last nibble
    let addressable = this.addressesLastNibble[pos >> 12];
    if (addressable) return addressable;

    // Registers
    if((address & 0xff00) === 0xff00) {
        addressable = this.addressesRegisters[pos & 0xff];
        if (addressable) return addressable;
    }

    if (pos <= 0xfdff) return this.wram;  // Echo RAM
    if (pos <= 0xfe9f) return this.ppu;   // OAM
    if (pos <= 0xfeff) return Register00; // Illegal Area

    return RegisterFF; // fake register
}
    \end{minted}
    \caption{Optimised implementation of \texttt{getAddress}}
    \label{fig:getaddress-after}
\end{figure}

To ensure placing the ``main block'' first was the best choice, measurements have been taken of four different \gls{gb} games. The emulator would log all memory accesses by groups of $100\,000\,000=10^8$, and categorise them by address ``blocks'': the main block, the \gls{oam} block, the illegal block (called like this because this area of memory is restricted by Nintendo, and only returns \texttt{0x00}) and the register block. This separation is justified by the fact these are the five chunks of memory that must be checked separately, due to their irregular boundaries. The \textit{second} set of $10^8$ accesses was then used to gather the statistics of what blocks are used the most. The first $10^8$ accesses aren't used, as they may include setup operations that only happen when the game loads, and as such don't represent what the average execution will look like. See figure \ref{fig:access-rates} for the results. 

% Data of the table:
% Alone in the Dark: { "most": 88_868_727, "echo": 0, "oam": 00_001_431, "illegal": 00_000_517, "registers": 11_129_325 }
% Link's Awakening DX: { "most": 95679115, "echo": 0, "oam": 0, "illegal": 0, "registers": 4320885 }
% Tetris: { "most": 84289047, "echo": 0, "oam": 0, "illegal": 0, "registers": 15710953 }
% Pokemon Silver: { "most": 95739934, "echo": 0, "oam": 0, "illegal": 0, "registers": 4260066 }

\begin{figure}[h]
    \centering
    \caption{Rounded access rate per memory blocks, for the second set of 10,000,000 accesses of 4 different games. Games are, respectively, ``Alone in the Dark: The New Nightmare'', ``The Legend of Zelda: Link's Awakening DX'', ``Tetris'' and ``Pokémon Silver''.}
    \begin{tabular}{|l|l|l|l|l|l|}
    \hline
    \textbf{Name} & \textbf{Memory Area} & \textbf{Game 1} & \textbf{Game 2} & \textbf{Game 3} & \textbf{Game 4}  \\ \hline
    Main Block & \texttt{0x0000}-\texttt{0xEFFF} 
    & 88.869\% 
    & 95.679\%
    & 84.289\% 
    & 95.740\% \\ \hline

    Echo RAM & \texttt{0xF000}-\texttt{0xFDFF} 
    & 0.000\% 
    & 0.000\%  
    & 0.000\% 
    & 0.000\% \\ \hline
    
    OAM Block & \texttt{0xFE00}-\texttt{0xFE9F} 
    & 0.001\% 
    & 0.000\%  
    & 0.000\% 
    & 0.000\% \\ \hline
    
    Illegal Block & \texttt{0xFEA0}-\texttt{0xFEFF} 
    & 0.001\% 
    & 0.000\%  
    & 0.000\% 
    & 0.000\% \\ \hline
    
    Register Block & \texttt{0xFF00}-\texttt{0xFFFF} 
    & 11.129\% 
    & 4.321\% 
    & 15.711\% 
    & 4.260\% \\ \hline
    \end{tabular}
    \label{fig:access-rates}
\end{figure}

As we can see, the great majority of memory accesses go to the main part of memory, with almost all of the rest going to the ``register area'', the last 256 bytes of the address space. This can easily be explained by the fact all registers that allow interaction with other components (the \gls{ppu}, the \gls{apu}, the timer, etc.) are in this narrow range, so it is bound to have a high usage. It is also quite interesting to note that neither the Echo RAM or the OAM block are used at all, except very rarely for one of the tested games. It is thus safe to assume that the conditions responsible for mapping these areas can be left at the end of the function, as they will rarely match an address.

\subsection{Evaluating the \texttt{getAddress} optimisation}

A simple experiment was then run, to verify the performance improvement. The first 25 million instructions of the \texttt{cpu\_instrs}\ftnt{https://github.com/retrio/gb-test-roms/tree/master/cpu_instrs} test \gls{rom} were run. This sample was chosen because it is considerably large, because the test itself requires around 25 million instructions to complete. For the measurement, \texttt{window.performance.now()}\ftnt{https://developer.mozilla.org/en-US/docs/Web/API/Performance/now} was used before and after each drawn frame, and the values were then summed.

The result was the following: $33\,955.9$ms before the change, and $20\,039.1$ after the change. The relative difference is thus $\frac{20\,039.1-33\,955.9}{33\,955.9}=-0.4098$, thus reducing time taken by $40.98\%$. By measuring the time spent within \texttt{getAddress} for these 25 million instructions, we get a total spent time in the method of $0.000\,151$ms on average, showing that this method is no longer a bottleneck for the system, as its impact on performance is minimal.

\section{Emulator Backend}

To keep the logic of the hardware, divided in different components, the structure of the emulator has a similar format, with different classes implementing the behaviour of the different parts of the \glsdesc{gb}.

\subsection{Addressable}

The \texttt{Addressable} interface is implemented by most classes of the emulator: \texttt{System}, \texttt{Register}, \texttt{MBC}, etc. It is simple, and provides a read and a write method (see figure \ref{fig:addressable}). The advantage of using it is that when implementing adressing logic with large switch-statements I can simply return any type of components that adheres to the interface, and the receiving method is agnostic of if it's dealing with a register, memory, or a component.

\begin{figure}[h]
    \begin{minted}{typescript}
interface Addressable {
    read(pos: number): number;
    write(pos: number, data: number): void;
}
    \end{minted}
    \caption{\texttt{Addressable} interface method}
    \label{fig:addressable}
\end{figure}

\subsection{Timer}
\subsection{PPU}
\subsection{OAM and OAM DMA}
\subsection{APU}
\subsection{MBCs and ROMs}

\chapter{Evaluation}


\clearpage

\printnoidxglossary[type=\acronymtype]

\printnoidxglossary[type=main]

\printbibliography


\end{document}
